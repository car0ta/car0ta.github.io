{"meta":{"title":"car0ta","subtitle":"car0ta's blog","description":null,"author":"car0ta","url":"https://car0ta.github.io","root":"/"},"pages":[{"title":"About","date":"2019-09-18T11:21:07.000Z","updated":"2022-04-22T07:35:05.575Z","comments":true,"path":"about/index.html","permalink":"https://car0ta.github.io/about/index.html","excerpt":"","text":"个人简介 ID：car0ta 研究方向：Android 安全，程序分析，白盒审计 名言警句 物来顺应 | 未来不迎 | 当时不杂 | 既过不恋"},{"title":"Categories","date":"2022-04-14T03:52:23.000Z","updated":"2022-12-10T14:31:14.989Z","comments":true,"path":"categories/index.html","permalink":"https://car0ta.github.io/categories/index.html","excerpt":"","text":""},{"title":"Link","date":"2019-09-18T11:20:04.000Z","updated":"2022-12-10T14:19:28.030Z","comments":true,"path":"link/index.html","permalink":"https://car0ta.github.io/link/index.html","excerpt":"","text":"ll rt95 wangfaker c1ick 小羊们的博客 三两老友杂"},{"title":"Tags","date":"2020-09-29T17:31:06.000Z","updated":"2020-09-29T17:49:09.533Z","comments":true,"path":"tags/index.html","permalink":"https://car0ta.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Static Program Analysis (IFDS)","slug":"Static-Program-Analysis-IFDS","date":"2023-04-11T03:07:26.000Z","updated":"2023-04-13T02:34:58.298Z","comments":true,"path":"2023/04/11/Static-Program-Analysis-IFDS/","link":"","permalink":"https://car0ta.github.io/2023/04/11/Static-Program-Analysis-IFDS/","excerpt":"","text":"Feasible and Realizable Paths Infeasible Paths: Path in CFG that do not correspond to actual executions. 对于程序分析而言，不希望分析结果被实际不可执行的路径所污染（误报）；但一条路径是否可执行通常是无法判断的。 例如下面代码中参数 age 一定是个正整数，因此 r=-1 这条路径动态实际不会执行到（infeasible path）。 foo(int age) { if (age &gt;=0) { r = age; } else { r = -1; } return r;} 对于下图中的代码，实际运行的结果应该是 x=18; y=30，但是如果采用上下文不敏感的静态分析，结果是 x=18,30,-1; y=18,30,-1。其中，x=-1; y=-1 是不可避免的，但是 foo(18) 的 return 应该回到相应的 call 处，即 call foo(18) -&gt; exit(foo) -&gt; x=return foo 是可以分析出来的，因此 x=30; y=18 是可以避免的。 Realizable Paths: The paths in which “returns” are matched with corresponding “calls”. Realizable paths 可能不会被实际执行（可能某个 call-site 是 infeasible path），但是 unrealizable paths 是一定不会被执行的。因此我们的目标是识别 Realizable paths，从而避免分析结果被 unrealizable paths 所污染。 那么如何识别出 Realizable paths 呢？一个简单的方法就是括号匹配。但是如果调用栈很大的话匹配的情况就会很复杂，因此需要一种系统的识别方法，即 CFL-Reachability。 CFL-Reachability CFL-Reachability: A path is considered to connect two nodes A and B, or B is reachable from A, only if the concatenation of the labels on the edges of the path is a word in a specified context-free language. 简单来说，一条路径是 Realizable path 当且仅当路径上每条边相关的 label 能够组成一个合法的单词，且单词满足上下文无关语言（CFL）的定义。 上下文无关语言是由上下文无关文法（context-free grammar, CFG）生成的。 CFG 是一个形式化的文法，每一个产生式的格式为 S -&gt; α ，其中 S 是单个非终止符，α 是一个由终止符和/或非终止符组成的字符串，或者为空。 上下文无关（context-free）意味着 S 可以在任何地方被 aSb/ε 替换，而不管 S 的上下文。 有了 CFL-Reachability 的定义，上述 Realizable Paths 的识别问题就转化为部分括号匹配问题（Partially Balanced-Parenthesis Problem）。 每一个右括号 )i 都需要有一个对应的左括号 (i，反之则不需要。 对于每一个 call-site i，给 call edge 添加 (i 标签，给 return edge 添加 )i 标签。 对于其他边用符号 e 标记。 一条路径是 realizable path 当且仅当 这条路径上所有边组成的单词满足语言 L(realizable) 的定义。 下面分别是满足和不满足上下文无关语言 L(realizable) 的路径： Overview of IFDS Precise Interprocedural Dataflow Analysis via Graph Reachability (POPL’15) IFDS: Interprocedural, Finite, Distributive, Subset Problem. IFDS 是用来解决过程间数据流分析问题，这些问题需满足三个条件：（1）分析的 domain 是有限的；（2）flow function 是满足分配率的；（3）是一个子集类型的问题。 IFDS 能够提供 meet-over-all-realizable-paths (MRP) 分析。 meet-over-all-realizable-paths (MRP) Overview 给定一个程序 P，一个数据流分析问题 Q 构建程序 P 的 supergraph G*（类似于 ICFG），基于问题 Q 为 G* 中的边定义 flow functions（类似于之前的 transfer functions）。 通过将 flow functions 转换为 representation relations，构建 exploded supergraph G#。 在 G* 上应用 Tabulation algorithm，问题 Q 可以通过图可达问题解决（找到 MRP 的解法）。 对于一个程序点 n，data fact d ∈ MRPn 当且仅当存在一条从 &lt;Smain, 0&gt; 到 &lt;n, d&gt; 的可达路径。 Supergraph and Flow Functions Exploded Supergraph and Tabulation Algorithm Understanding the Distributivity of IFDS","categories":[{"name":"Program Analysis","slug":"Program-Analysis","permalink":"https://car0ta.github.io/categories/Program-Analysis/"}],"tags":[{"name":"Static Program Analysis","slug":"Static-Program-Analysis","permalink":"https://car0ta.github.io/tags/Static-Program-Analysis/"}]},{"title":"Android PendingIntent 重定向漏洞","slug":"Android-PendingIntent-重定向漏洞","date":"2022-09-17T14:51:40.000Z","updated":"2022-09-17T15:22:22.067Z","comments":true,"path":"2022/09/17/Android-PendingIntent-重定向漏洞/","link":"","permalink":"https://car0ta.github.io/2022/09/17/Android-PendingIntent-%E9%87%8D%E5%AE%9A%E5%90%91%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"本文来源于 blackhat Europe 2021 中的议题：Re-route Your Intent for Privilege Escalation: An Universal Way to Exploit Android PendingIntents in High-profile and System App，作者是来自 OPPO 子午互联网安全实验室的 En He, Wenbo Chen, Daoyuan Wu。 背景知识 Intent 在 Android 系统中，Intent 是在组件间传递的通信消息，用于执行启动活动、发送广播、启动服务等动作；而 Intent 对象内部的字段则规定了 Intent 发送的目的组件，以及执行动作的具体内容，包括 action、category、data、clipdata、package、flag、extra、component 和 selector。 其中，component 和 selector 用于设置 Intent 的目的组件，规定 Intent 发送给谁。按照是否设置 component 和 selector，Intent 可分为： 显示 Intent：具有 component 或者 selector 的 Intent 隐式 Intent：仅设置了 action 的 Intent，注册对应 action 的 Intent-filter 的组件可以接收到 Intent。 另外还有一种特殊的空 Intent：既没有设置 component 或 selector，也没有设置 action，甚至没有任何字段。 引申：如果一个 Intent 设置了 component，那么它的 package 字段将被忽略（即使被设置），利用此特点可能绕过某些检查，例如 CVE-2022-20223。 PendingIntent PendingIntent 可以看做 Intent 的高级版本，实现了一种委托授权发送 Intent 进行组件间通信的机制。 首先，App 可以使用 getActivity、getBroadcast、getService 等 API 向 Android 系统申请一个 PendingIntent 对象。例如在 getActivity 函数中，intent 参数构成了所生成的 PendingIntent 对象的 base intent，flags 参数决定了 PendingIntent 的行为，例如 FLAG_IMMUTABLE 就用于规定 base Intent 不能被改写。 然后，这个 PendingIntent 对象可以发送给其他 App 使用，其他 App 调用 PendingIntent.send 时，就能够以 PendingIntent 源 App 的身份和权限发送 PendingIntent 中的 base Intent。其他 App 甚至能提供一个新的 Intent，对 base Intent 进行改写。 因此，App A 将 PendingIntent 交给 App B，意味着将自己的身份与权限连同要执行的操作委托给了 App B，这个操作由 PendingIntent 中的 base Intent 确定。如果恶意 App 有能力获取上述通信过程中的 PendingIntent 并修改其 base Intent，就可能以源 App 的身份和权限发送修改后的 base Intent，从而造成非预期的安全后果。 历史研究 BroadcastAnyWhere 该漏洞出现在 Settings 添加账户的时候，使用 AccountManager 添加账户的流程如下图： 漏洞发生在 step 1，Settings 调用了 AccountManager.addAccount 方法，在传递 addAccountOptions 时加入了一个 PendingIntent，其 Intent 类型为 Broadcast。 private void addAccount(String accountType) { Bundle addAccountOptions = new Bundle(); mPendingIntent = PendingIntent.getBroadcast(this, 0, new Intent(), 0); addAccountOptions.putParcelable(KEY_CALLER_IDENTITY, mPendingIntent); addAccountOptions.putBoolean(EXTRA_HAS_MULTIPLE_USERS, Utils.hasMultipleUsers(this)); AccountManager.get(this).addAccount( 由于这个广播 PendingIntent 由 system_server AccountManagerService(uid 1000) 所创建，代表了系统的身份和权限，且并未设置 base Intent 的其他字段。普通 Authenticator App 拿到以后，改写其 base Intent，例如设置一个 action android.intent.action.BOOT_COMPLETED，最后调用 PendingIntent.send 以 uid 1000 的身份发送特权广播。 PendingIntent pending_intent = (PendingIntent)options.get(\"pendingIntent\");intent.setAction(\"android.intent.action.BOOT_COMPLETED\"); try { pending_intent.send(getGlobalApplicationContext(),0,intent,null,null,null);} catch (CanceledException e) { e.printStackTrace();} LINE App 另一个案例出现在即时通信软件 LINE App 启动服务时泄露了一个 PendingIntent 对象，且 base Intent 为空 Intent。因此恶意APP可以注册一个 Intent-filter 为jp.naver.android.npush.intent.action.SUBSCRIBE 的服务，然后获取上面的 PendingIntent，最后以 LINE App 的身份发送广播，造成伪造 LINE App 推送消息的危害。 PendingIntent 的使用场景 在 Android 系统中，PendingIntent 还广泛存在于 SliceProviders、Notifications、MediaBrowserService、AppWidgets、AlarmManager 等服务当中。因此现在的问题是如何获取 Android 系统中广泛使用的 PendingIntent 并进行利用。 不安全 PendingIntent 的通用利用方法 不安全 PendingIntent 的特征 从前面的历史研究中我们知道 empty base Intent 构建的 PendingIntent 是不安全的，那 Implicit base Intent 构建的 PendingIntent 是否安全呢？下文将深入探索这种形式的 PendingIntent 的安全问题及利用方式。 // empty base IntentmPendingIntent = PendingIntent.getBroadcast(this, 0, new Intent(), 0);// implicit base IntentmPendingIntent = PendingIntent.getActivity(this, 0, new Intent(\"some.Action\"), 0); 深入 Intent fillIn 改写机制 在寻找利用之前先要深入探索 Intent fillIn 改写机制，这决定了其他 App 获得 PendingIntent 后如何对 base Intent 进行改写。这个机制由 Intent.fillIn 方法提供： public int fillIn(@NonNull Intent other, @FillInFlags int flags) { int changes = 0; boolean mayHaveCopiedUris = false; if (other.mAction != null &amp;&amp; (mAction == null || (flags&amp;FILL_IN_ACTION) != 0)) { mAction = other.mAction; changes |= FILL_IN_ACTION; } if ((other.mData != null || other.mType != null) &amp;&amp; ((mData == null &amp;&amp; mType == null) || (flags&amp;FILL_IN_DATA) != 0)) { mData = other.mData; mType = other.mType; changes |= FILL_IN_DATA; mayHaveCopiedUris = true; } if (other.mIdentifier != null &amp;&amp; (mIdentifier == null || (flags&amp;FILL_IN_IDENTIFIER) != 0)) { mIdentifier = other.mIdentifier; changes |= FILL_IN_IDENTIFIER; } if (other.mCategories != null &amp;&amp; (mCategories == null || (flags&amp;FILL_IN_CATEGORIES) != 0)) { if (other.mCategories != null) { mCategories = new ArraySet&lt;String&gt;(other.mCategories); } changes |= FILL_IN_CATEGORIES; } if (other.mPackage != null &amp;&amp; (mPackage == null || (flags&amp;FILL_IN_PACKAGE) != 0)) { // Only do this if mSelector is not set. if (mSelector == null) { mPackage = other.mPackage; changes |= FILL_IN_PACKAGE; } } // Selector is special: it can only be set if explicitly allowed, // for the same reason as the component name. if (other.mSelector != null &amp;&amp; (flags&amp;FILL_IN_SELECTOR) != 0) { if (mPackage == null) { mSelector = new Intent(other.mSelector); mPackage = null; changes |= FILL_IN_SELECTOR; } } if (other.mClipData != null &amp;&amp; (mClipData == null || (flags&amp;FILL_IN_CLIP_DATA) != 0)) { mClipData = other.mClipData; changes |= FILL_IN_CLIP_DATA; mayHaveCopiedUris = true; } // Component is special: it can -only- be set if explicitly allowed, // since otherwise the sender could force the intent somewhere the // originator didn't intend. if (other.mComponent != null &amp;&amp; (flags&amp;FILL_IN_COMPONENT) != 0) { mComponent = other.mComponent; changes |= FILL_IN_COMPONENT; } mFlags |= other.mFlags; if (other.mSourceBounds != null &amp;&amp; (mSourceBounds == null || (flags&amp;FILL_IN_SOURCE_BOUNDS) != 0)) { mSourceBounds = new Rect(other.mSourceBounds); changes |= FILL_IN_SOURCE_BOUNDS; } if (mExtras == null) { if (other.mExtras != null) { mExtras = new Bundle(other.mExtras); mayHaveCopiedUris = true; } } else if (other.mExtras != null) { try { Bundle newb = new Bundle(other.mExtras); newb.putAll(mExtras); mExtras = newb; mayHaveCopiedUris = true; } catch (RuntimeException e) { // Modifying the extras can cause us to unparcel the contents // of the bundle, and if we do this in the system process that // may fail. We really should handle this (i.e., the Bundle // impl shouldn't be on top of a plain map), but for now just // ignore it and keep the original contents. :( Log.w(TAG, \"Failure filling in extras\", e); } } if (mayHaveCopiedUris &amp;&amp; mContentUserHint == UserHandle.USER_CURRENT &amp;&amp; other.mContentUserHint != UserHandle.USER_CURRENT) { mContentUserHint = other.mContentUserHint; } return changes;} 上述代码中，this 指向当前 Intent，other 为其他 Intent，如果当前 Intent 中的成员变量为空则可以被 other 中相应的成员变量覆盖。特别的是 Intent 中的 component 和 selector 成员变量，即使当前 Intent 中的 component 和 selector 为空，也不能被 other 改写，除非 PendingIntent 设置了 FILL_IN_COMPONENT 或 FILL_IN_SELECTOR 标志。 PendingIntent 重定向攻击 了解了 Intent fillIn 机制后可以知道，在获取 PendingIntent 对象之后，其 base Intent 的 action、category、data、clidpdata、package、flag、extra 等成员都是可以改写的，而 component 和 selector 不能改写。而对于 Implicit base Intent，因为 action 已经被设置了，所以也无法改写。因此攻击者不能像前面 BroadcastAnyWhere 漏洞一样，通过劫持 PendingIntent 并在 base Intent 中设置 action，隐式打开一个受保护的组件。 因为 package 字段可以指定，同时联想到 Intent 重定向漏洞的利用方法，我们可以通过设置 Intent 中的 flag 来巧妙解决。Intent 提供了有关临时授权的标志： FLAG_GRANT_READ_URI_PERMISSION：Intent 携带此标志时，Intent 的接收者将 Intent 所携带 data URI 以及 clipdata URI 中的读权限；F LAG_GRANT_WRITE_URI_PERMISSION：Intent 携带此标志时，Intent 的接收者将 Intent 所携带 data URI 以及 clipdata URI 中的写权限。 简言之，恶意 App 对 PendingIntent 进行了指向恶意 App 自己的重定向，通过对 PendingIntent base Intent 的部分修改（修改package、flag 和 data/clipdata），使其以受害 App 的权限打开恶意 App 自身，这样恶意 App 在被打开的瞬间就获得了对受害 App 私有数据的 读写权限。具体利用方式如下图所示： 受害 App 通过 getActivity 构建 PendingIntent（假定使用的是 Implicit base Intent），在 Notifications、SliceProviders、AppWidgets 等服务中使用，攻击 App 通过 Bind/Connect/Listen 方法与相关服务建立连接； 攻击 App 通过前面探讨的各种渠道获取受害 App 的 PendingIntent； 攻击 App 修改 PendingIntent 中的 base Intent，由于是 Implicit Intent，因此 action、component、selector 都不能被修改，但可以作如下修改： 修改 data/clipdata，使其 URI 指向受害 App 的私有ContentProvider 修改 package，指向攻击 App 添加 FLAG_GRANT_READ_URI_PERMISSION 和 FLAG_GRANT_WRITE_URI_PERMISSION 标志 攻击者调用 PendingIntent.send； 由于这个 PendingIntent 代表了受害 App 的身份和权限，因此将以受害 App 的名义发Intent，打开攻击 App 的 Activity； 在攻击 App 的 Activity 被打开的瞬间，即被授权访问 base Intent 中携带的 URI，也就获得了对受害 App 私有 ContentProvider 的读写权限。 上面受害 App 的私有 ContentProvider 需要携带属性 grantUriPermission=true，不限于受害 App 自己的 ContentProvider，也包括受害 App 有权限访问的 ContentProvider。手机上一个常见的具有 grantUriPermission=true 属性的 ContentProvider 就是代表通讯录的 ContentProvider，只要受害 App 具有 READ_CONTACTS 权限，出现这样一个 PendingIntent 漏洞猴将导致通讯录泄露。 由于这里使用了 grantUri 技巧，因此并不适用于 Broadcast PendingIntent，因为广播接收器是不可以被 grantUri 的。另外，从 Android 5.0 之后，Service 不能被隐式启动，因此也很难看到 Implicit base Intent 的 service PendingIntent，所以这里的 PendingIntent 重定向攻击主要适用于 Activity。 Android 系统中的真实案例 ID Found in Impact CVE-2020-0188 AOSP Settings SliceProvider Theft of Some Settings Provider CVE-2020-0389 AOSP SystemUI Notification Theft of Contacts Provider or Arbitrary Code Execution A-166126300 AOSP Bluetooth MediaBrowserService Theft of Contacts Provider - Some super popular app’s AppWidgets Theft of Contacs Provider or Arbitrary Code Execution CVE-2020-0294 AOSP System Services Theft of Settings Provide 基于对 PendingIntent 特征的掌握，作者编写了一个自动化扫描工具 PendingIntentScan，该工具基于 Soot 这一 Java 静态分析框架对 APK 进行静态数据流分析。 CVE-2020-0188: SliceProvider CVE-2020-0389: Notification CVE-2020-0294: System Service Android 12 安全变更 针对以上漏洞的修复，Google Android 安全团队大部分使用了 PendingIntent.FLAG_IMMUTABLE，小部分的修复将 base Intent 设置为 Explicit Intent。在 Android 12 大版本中，Google Android 安全团队对 PendingIntent 的行为进行了重大安全变更，引入了一个新的 flag：PendingIntent.FLAG_MUTABLE，表示 base Intent 可以改写，这与原有的 PendingIntent.FLAG_IMMUTABLE 共同描述 PendingIntent 的可变性。 对于 Target S+ 的 App，Android 系统要求开发者必须明确指定 PendingIntent 的可变性，FLAG_MUTABLE 和 FLAG_IMMUTABLE 必须使用其一，否则抛出异常。这就要求开发者对 PendingIntent 的使用有清晰的理解，知道 PendingIntent 是否会在将来被改写。Google 也对开发者提出了详细的安全编码建议： 尽可能使用 FLAG_IMMUTABLE 来生成不可改写的 PendingIntent； 如果使用 FLAG_MUTABLE 来生成可改写的 PendingIntent，base Intent 一定要使用 Explicit Intent，明确指定 Intent 的组件。 参考 PendingIntent重定向：一种针对安卓系统和流行App的通用提权方法——BlackHat EU 2021议题详解 https://segmentfault.com/a/1190000041532963 https://segmentfault.com/a/1190000041550819 https://www.blackhat.com/eu-21/briefings/schedule/index.html#re-route-your-intent-for-privilege-escalation-a-universal-way-to-exploit-android-pendingintents-in-high-profile-and-system-apps-24340 broadAnywhere：Broadcast组件权限绕过漏洞（Bug: 17356824） http://retme.net/index.php/2014/11/14/broadAnywhere-bug-17356824.htmlAndroid App 安全之 Intent 重定向详解 https://www.freebuf.com/articles/endpoint/271629.html","categories":[{"name":"Android Vuls","slug":"Android-Vuls","permalink":"https://car0ta.github.io/categories/Android-Vuls/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://car0ta.github.io/tags/Android/"},{"name":"Vuls","slug":"Vuls","permalink":"https://car0ta.github.io/tags/Vuls/"}]},{"title":"Android 序列化与反序列化不匹配漏洞","slug":"Android-序列化与反序列化不匹配漏洞","date":"2022-09-08T10:59:20.000Z","updated":"2022-09-08T11:14:37.164Z","comments":true,"path":"2022/09/08/Android-序列化与反序列化不匹配漏洞/","link":"","permalink":"https://car0ta.github.io/2022/09/08/Android-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8D%E5%8C%B9%E9%85%8D%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"历史漏洞整理 CVE 编号 Parcelable 对象 公布时间 CVE-2017-0806 GateKeeperResponse 2017.10 CVE-2017-13286 OutputConfiguration 2018.04 CVE-2017-13287 VerifyCredentialResponse 2018.04 CVE-2017-13288 PeriodicAdvertisingReport 2018.04 CVE-2017-13289 ParcelableRttResults 2018.04 CVE-2017-13315 DcParamObject 2018.05 CVE-2021-0928 OutputConfiguration, SessionConfiguration, VendorTagDescriptor, VendorTagDescriptorCache 2021.11 CVE-2021-39676 AndroidFuture 2022.02 背景知识 Android Parcelable 序列化 简单来说，序列化就是将对象转换为可以传输或存储的二进制流（二进制序列）的过程，反序列化则是从二进制流（二进制序列）转化为对象的过程。 在 Android 中序列化有两种方式：Serializable 和 Parcelable。其中 Serializable 接口是 JavaSE 本省就支持的，实现简单但效率较低，只需要 implements Serializable 即可；而 Parcelable 接口是 Android 中特有的，实现较为复杂但效率更高，需要重写 Parcelable 中的四个方法（describeContents, writeToParcel, createFromParcel, newArray），可用于 Intent 数据传递和进程间通信（IPC）。 下面代码是一个典型的 Parcelable 序列化使用样例，其中重写的 writeToParcel 和 createFromParcel 方法对应序列化（写）和反序列化（读）操作，具体则是调用了 Parcel 类中一系列对称的 write 和 read 方法。 public class MyParcelable implements Parcelable { private String paramsA; private int paramsB; private boolean paramsC; public MyParcelable() { } public MyParcelable(String paramsA, int paramsB, boolean paramsC) { this.paramsA = paramsA; this.paramsB = paramsB; this.paramsC = paramsC; } public String getParamsA() { return paramsA; } public void setParamsA(String paramsA) { this.paramsA = paramsA; } public int getParamsB() { return paramsB; } public void setParamsB(int paramsB) { this.paramsB = paramsB; } public boolean isParamsC() { return paramsC; } public void setParamsC(boolean paramsC) { this.paramsC = paramsC; } @Override public int describeContents() { return 0; } @Override public void writeToParcel(Parcel dest, int flags) { dest.writeString(this.paramsA); dest.writeInt(this.paramsB); dest.writeByte(this.paramsC ? (byte) 1 : (byte) 0); } protected MyParcelable(Parcel in) { this.paramsA = in.readString(); this.paramsB = in.readInt(); this.paramsC = in.readByte() != 0; } public static final Creator&lt;MyParcelable&gt; CREATOR = new Creator&lt;MyParcelable&gt;() { @Override public MyParcelable createFromParcel(Parcel source) { return new MyParcelable(source); } @Override public MyParcelable[] newArray(int size) { return new MyParcelable[size]; } };} 进一步了解 Parcel。Parcel 翻译是打包的意思，也就是包装我们需要传输的数据，然后在 Binder 中传输（跨进程数据传输），简单来说它是一个用于 IBinder 发送消息的容器。Parcel 提供了一套机制，可以将序列化之后的数据写入到一个共享内存中，其他进程通过 Parcel 从共享内存中读取字节流并反序列化成对象。一个 Parcel 容器可以包含原始数据类型及其数组类型，也可以包含 Parcelable 对象，还可以包含指向 IBinder 对象的引用。 Android Bundle 可序列化的 Parcelable 对象一般不单独进行序列化传输，需要通过 Bundle 对象携带。Bundle 的内部实现实际上是 ArrayMap，以 key-value 的形式存储数据。key 为 string 类型，value 可以是 string、int、boolean、byte、float、long、double 等基本类型或它们对应的数组，也可以是对象或对象数组。当 bundle 传递的是对象或对象数组时，必须实现 Serialiable 或 Parcelable 接口。 Android 中组件间通信（ICC）频繁使用到的是 Intent，在 Intent 源码中有一个 mExtras 字段，它就是一个 Bundle 容器，可用于数据传递。当我们调用 Intent.putExtra(String key, XXX value) 方法向 Intent 中写入数据时，实际上调用的是 Bundle.putXXX(String key, XXX value) 方法向 Intent.mExtras 这个 Bundle 容器中写入数据。 Bundle 序列化过程如下：依次写入 Bundle 携带数据的长度、Bundle 魔数（0x4C444E42）和所有的键值对（writeArrayMapInternal）。 frameworks/base/core/java/android/os/BaseBundle.java void writeToParcelInner(Parcel parcel, int flags) { // If the parcel has a read-write helper, we can't just copy the blob, so unparcel it first. if (parcel.hasReadWriteHelper()) { unparcel(); } // Keep implementation in sync with writeToParcel() in // frameworks/native/libs/binder/PersistableBundle.cpp. final ArrayMap&lt;String, Object&gt; map; synchronized (this) { // unparcel() can race with this method and cause the parcel to recycle // at the wrong time. So synchronize access the mParcelledData's content. if (mParcelledData != null) { if (mParcelledData == NoImagePreloadHolder.EMPTY_PARCEL) { parcel.writeInt(0); } else { int length = mParcelledData.dataSize(); parcel.writeInt(length); parcel.writeInt(mParcelledByNative ? BUNDLE_MAGIC_NATIVE : BUNDLE_MAGIC); parcel.appendFrom(mParcelledData, 0, length); } return; } map = mMap; } // Special case for empty bundles. if (map == null || map.size() &lt;= 0) { parcel.writeInt(0); return; } int lengthPos = parcel.dataPosition(); parcel.writeInt(-1); // placeholder, will hold length parcel.writeInt(BUNDLE_MAGIC); int startPos = parcel.dataPosition(); parcel.writeArrayMapInternal(map); int endPos = parcel.dataPosition(); // Backpatch length parcel.setDataPosition(lengthPos); int length = endPos - startPos; parcel.writeInt(length); parcel.setDataPosition(endPos);} Bundle 反序列化过程和序列化过程完全对称，依次读取 Bundle 携带数据的长度、Bundle 魔数和所有键值对。 LaunchAnyWhere 漏洞 该漏洞源于 Google 的一次漏洞修复，记为 Google Bug 7699048。这是一个 AccountManagerService 的漏洞，利用该漏洞可以启动任意的 Activity，包括未导出的 Activity（不能被外部应用调用的 Activity），从而突破进程间组件访问隔离的限制。该漏洞影响范围为 Android 2.3-4.3。 首先了解一下 AccountManagerService 这个系统服务。该服务用于管理用户的各种网络帐号，主要涉及帐号的添加和删除，以及 AuthToken 的获取和更新。AccountManagerService 暴露给开发者的接口是 AccountManager，应用开发者可以利用该接口将应用的帐号信息交给系统管理，并与后台服务端自认证处理，这样避免了每次进入应用都需要用户手动输入用户名密码进行验证的繁琐操作。 添加账户有两种方式：1. 在“设置-&gt;帐号-&gt;添加帐号”中手动添加可提供网络帐号的应用；2. 可提供网络帐号的应用调用 com.android.settings.accounts.AddAccountSettings 接口，让 Settings 自动触发 addAccount 的操作。 该漏洞的利用过程如下图所示： Step 0：攻击程序 AppB 调用 com.android.settings.accounts.AddAccountSettings 接口； Step 1：Settings 触发 addAccount 操作，向 AccountManagerService 请求添加特定类型的网络帐号； Step 2：system_server 查询到 AppB 可以提供该类型的网络帐号，因此向 AppB 发起请求； Step 3：AppB 返回了一个 Bundle 给 system_server，该 Bundle 中包含一个恶意 intent，可以调用想要攻击的 Activity； Step 4：AccountManagerResponse 在 Settings 的进程空间内调用 startActivity(intent) 启动待攻击的 Activity，而 Settings 并不知情。 这种设计的本意是，AccountManagerService 帮助 Settings 查找到 AppB 账号登陆页面，并呼起这个登陆页面。而问题在于，AppB 可以任意指定这个 intent 所指向的组件，Settings 将在不知情的情况下由 AccountManagerResponse 调用起了一个 Activity。而 Settings 作为一个系统应用，能够调用起任意 AppB 指定的未导出 Activity。 Google 在 Android 4.4 中进行了修复，在 AccountManagerService 中对指定的 intent 进行了检查，确保 intent 所指向的 Activity的所属包 与 AppB 具有相同签名。 + @Override public void onResult(Bundle result) { mNumResults++;- if (result != null &amp;&amp; !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) {+ Intent intent = null;+ if (result != null+ &amp;&amp; (intent = result.getParcelable(AccountManager.KEY_INTENT)) != null) {+ /*+ * The Authenticator API allows third party authenticators to+ * supply arbitrary intents to other apps that they can run,+ * this can be very bad when those apps are in the system like+ * the System Settings.+ */+ PackageManager pm = mContext.getPackageManager();+ ResolveInfo resolveInfo = pm.resolveActivity(intent, 0);+ int targetUid = resolveInfo.activityInfo.applicationInfo.uid;+ int authenticatorUid = Binder.getCallingUid();+ if (PackageManager.SIGNATURE_MATCH !=+ pm.checkSignatures(authenticatorUid, targetUid)) {+ throw new SecurityException(+ \"Activity to be started with KEY_INTENT must \" ++ \"share Authenticator's signatures\");+ }+ }+ if (result != null+ &amp;&amp; !TextUtils.isEmpty(result.getString(AccountManager.KEY_AUTHTOKEN))) { AccountManagerService 添加对 intent 的检查之后，上述利用图示则涉及到两次跨进程的序列化数据传输。第一次，AppB将 Bundle 序列化后通过 Binder 传递给 system_server，然后 system_server 通过 Bundle 的 getXXX 方法触发反序列化，获得 KEY_INTENT 这个键所对应的值——一个 Intent 对象，并进行安全检查。若检查通过则调用 writeBundle 进行第二次序列化传输，最后在 Settings 中反序列化后重新获得 {KEY_INTENT: intent}，最终启动相应的 Activity。 如果 Android 系统中某些 Parcelable 对象的序列化和反序列化过程不匹配，那么就有可能通过精心构造的 payload，使得上述攻击流程中第一次序列化和反序列化匹配，而第二次序列化和反序列化不匹配，从而完美绕过 checkKeyIntent 的检查，最终在 Settings 中暴露出恶意的 KEY_INTENT。 CVE-2017-0806 该漏洞由 Michal Bednarski 发现，应该是历史上第一个公开的 Android 序列化与反序列化不匹配漏洞，影响的 AOSP 范围为 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2, 8.0。 frameworks/base/core/java/android/service/gatekeeper/GateKeeperResponse.java public static final Parcelable.Creator&lt;GateKeeperResponse&gt; CREATOR = new Parcelable.Creator&lt;GateKeeperResponse&gt;() { @Override public GateKeeperResponse createFromParcel(Parcel source) { int responseCode = source.readInt(); final GateKeeperResponse response; if (responseCode == RESPONSE_RETRY) { response = createRetryResponse(source.readInt()); } else if (responseCode == RESPONSE_OK) { final boolean shouldReEnroll = source.readInt() == 1; byte[] payload = null; int size = source.readInt(); if (size &gt; 0) { payload = new byte[size]; source.readByteArray(payload); } response = createOkResponse(payload, shouldReEnroll); } else { response = createGenericResponse(responseCode); } return response; } @Override public GateKeeperResponse[] newArray(int size) { return new GateKeeperResponse[size]; }};@Overridepublic void writeToParcel(Parcel dest, int flags) { dest.writeInt(mResponseCode); if (mResponseCode == RESPONSE_RETRY) { dest.writeInt(mTimeout); } else if (mResponseCode == RESPONSE_OK) { dest.writeInt(mShouldReEnroll ? 1 : 0); if (mPayload != null) { dest.writeInt(mPayload.length); dest.writeByteArray(mPayload); } }} CVE-2021-39676 参考 Bundle风水——Android序列化与反序列化不匹配漏洞详解 https://xz.aliyun.com/t/2364 launchAnyWhere: Activity组件权限绕过漏洞解析(Google Bug 7699048) http://retme.net/index.php/2014/08/20/launchAnyWhere.html 安卓漏洞 CVE 2017-13287 复现分析 https://www.anquanke.com/post/id/197710 CVE-2021-39676 AndroidFuture反序列化漏洞分析 https://wrlus.com/android-security/cve-2021-39676/ Android 序列化与反序列化 https://www.jianshu.com/p/c2a6161f1546 Android Intent 详解 https://www.jianshu.com/p/19147a69e970 Android Bundle 机制详解 https://www.jianshu.com/p/0a50acfbf268 AccountManagerService 浅析 https://www.jianshu.com/p/2609f7a8b034 CVE-2017-0806 PoC https://github.com/michalbednarski/ReparcelBug","categories":[{"name":"Android Vuls","slug":"Android-Vuls","permalink":"https://car0ta.github.io/categories/Android-Vuls/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://car0ta.github.io/tags/Android/"},{"name":"Vuls","slug":"Vuls","permalink":"https://car0ta.github.io/tags/Vuls/"}]},{"title":"AppSearch in Android 12","slug":"AppSearch-in-Android-12","date":"2022-06-12T13:43:02.000Z","updated":"2022-06-18T11:39:16.918Z","comments":true,"path":"2022/06/12/AppSearch-in-Android-12/","link":"","permalink":"https://car0ta.github.io/2022/06/12/AppSearch-in-Android-12/","excerpt":"","text":"Workflow： 熟悉并使用 AppSearch 功能 梳理 API 调用并分析攻击面 阅读源码和动态调试（可能存在的 native 实现） Research Question： 创建会话、插入数据是否有上限，能否造成 DoS？ 查询数据能否突破应用内存储限制，达成 EoP？ Introduction AppSearch 是一个搜索库，用于管理本地结构化数据；支持通过索引写入数据和通过全文本搜索（full-text search）来读取数据；Apps 可以使用 AppSearch 来实现应用内搜索功能且支持离线查找。 AppSearch 主要特点： 快速且低 I/O 使用的移动端存储实现 在大型数据集上高效索引和查询 多语言支持（英语、西班牙语等） 相关性排名（ranking）和使用评分（score） 和 SQLite 相比，AppSearch 索引和查询数据的延迟（latency）更低，且简化了跨类型（cross-type）查询。 AppSearch concepts Database and session 一个 AppSearch 数据库是一些满足该数据库结构（database schema）的 documents 的集合，client app 提供应用上下文（application context）和数据库名（database name）即可创建一个 AppSearch 数据库，该数据库只能被创建它的应用打开。打开数据库时，AppSearch 返回一个与 client App 相连接的 session，这个 session 就是 client app 调用 AppSearch API 的入口点，直到 client app 关闭 session。 Schema and schema types schema 表示一个 AppSearch 数据库中数据的组织结构，由代表着不同数据类型的 schema type 组成。一个 AppSearch 数据库只有设置了 schema type，属于这个 schema type 的 document 才能添加到数据库中。 Documents 一个 document 代表一个数据单元，一个 AppSearch 数据库中的每个 document 都被 namespace 和 ID 唯一标识。namespace 通常用来分开来自不同 source 的数据，如当查询来自 user accounts 的数据时。 Search 通过 query 可以查询满足特定条件的 documents。查询结果根据它们的 score 以及 ranking strategy 进行排序。 Platform Storage vs Local Storage Local Storage：一个 App 管理一个应用特有的索引，这些索引存储在该应用的 data 目录。 Platform Storage：App 的数据用于构建系统级别的中央索引，数据访问具有严格的限制。每个 App 只能访问该应用的数据以及其他 App 中显式共享的数据。 Features LocalStorage (compatible with Android 4.0+) PlatformStorage (compatible with Android 12+) Efficient full-text search T T Multi-language support T T Reduced binary size F T Application-to-application data sharing F T Capability to display data on System UI surfaces F T Unlimited document size and count can be indexed T F Faster operations without additional binder latency T F Get Started with AppSearch 添加依赖：在 Application’s build.gradle 文件添加如下依赖： （在 API 32 也就是 Android 13 中，AppSearch 作为内建库不再需要 implementation） dependencies { def appsearch_version = \"1.0.0-alpha04\" implementation \"androidx.appsearch:appsearch:$appsearch_version\" // Use kapt instead of annotationProcessor if writing Kotlin classes annotationProcessor \"androidx.appsearch:appsearch-compiler:$appsearch_version\" implementation \"androidx.appsearch:appsearch-local-storage:$appsearch_version\" // PlatformStorage is compatible with Android 12+ devices, and offers additional features // to LocalStorage. implementation \"androidx.appsearch:appsearch-platform-storage:$appsearch_version\"} 实现一个 document 类 @Documentpublic data class Note( // Required field for a document class. All documents MUST have a namespace. @Document.Namespace val namespace: String, // Required field for a document class. All documents MUST have an Id. @Document.Id val id: String, // Optional field for a document class, used to set the score of the // document. If this is not included in a document class, the score is set // to a default of 0. @Document.Score val score: Int, // Optional field for a document class, used to index a note's text for this // document class. @Document.StringProperty(indexingType = AppSearchSchema.StringPropertyConfig.INDEXING_TYPE_PREFIXES) val text: String) 创建一个数据库 val context: Context = getApplicationContext()val sessionFuture = LocalStorage.createSearchSession( LocalStorage.SearchContext.Builder(context, /*databaseName=*/\"notes_app\") .build()) 设置数据库的 schema val setSchemaRequest = SetSchemaRequest.Builder().addDocumentClasses(Note::class.java) .build()val setSchemaFuture = Futures.transformAsync( sessionFuture, { session -&gt; session?.setSchema(setSchemaRequest) }, mExecutor) 向数据库中插入 document val note = Note( namespace=\"user1\", id=\"noteId\", score=10, text=\"Buy fresh fruit\")val putRequest = PutDocumentsRequest.Builder().addDocuments(note).build()val putFuture = Futures.transformAsync( sessionFuture, { session -&gt; session?.put(putRequest) }, mExecutor)Futures.addCallback( putFuture, object : FutureCallback&lt;AppSearchBatchResult&lt;String, Void&gt;?&gt; { override fun onSuccess(result: AppSearchBatchResult&lt;String, Void&gt;?) { // Gets map of successful results from Id to Void val successfulResults = result?.successes // Gets map of failed results from Id to AppSearchResult val failedResults = result?.failures } override fun onFailure(t: Throwable) { Log.e(TAG, \"Failed to put documents.\", t) } }, mExecutor) 查找 val searchSpec = SearchSpec.Builder() .addFilterNamespaces(\"user1\") .build();val searchFuture = Futures.transform( sessionFuture, { session -&gt; session?.search(\"fruit\", searchSpec) }, mExecutor)Futures.addCallback( searchFuture, object : FutureCallback&lt;SearchResults&gt; { override fun onSuccess(searchResults: SearchResults?) { iterateSearchResults(searchResults) } override fun onFailure(t: Throwable?) { Log.e(\"TAG\", \"Failed to search notes in AppSearch.\", t) } }, mExecutor) AppSearch API 重点关注 PlatformStorage 数据访问控制：使用 PlatformStorage 时查询其他应用共享的数据，是否能够绕过授权查询不可访问的数据。 searchgetNextPageglobalQuery reference https://developer.android.com/guide/topics/search/appsearch https://mp.weixin.qq.com/s/TbzHpHRnBt95YaVaNKlTQQ","categories":[{"name":"Android OS","slug":"Android-OS","permalink":"https://car0ta.github.io/categories/Android-OS/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://car0ta.github.io/tags/Android/"}]},{"title":"Static Program Analysis (Datalog)","slug":"Static-Program-Analysis-Datalog","date":"2022-05-21T07:29:04.000Z","updated":"2022-12-10T14:22:47.504Z","comments":true,"path":"2022/05/21/Static-Program-Analysis-Datalog/","link":"","permalink":"https://car0ta.github.io/2022/05/21/Static-Program-Analysis-Datalog/","excerpt":"","text":"Motivation 命令式语言（imperative） vs. 声明式语言（declarative） 命令式语言在做指针分析时要实现很多的细节： 而使用声明式语言实现指针分析是非常简洁的，具有可读性，而且易于实现： Introduction to Datalog Datalog 是一个声明式逻辑编程语言，是 Prolog 的子集；起初作为数据库查询语言，后来用途越来越广泛。 Datalog = Data + Logic (and, or, not) No side-effects No control flows No functions Not Turing-complete Predicates (Data) Datalog 中一个谓词（predicate）是一系列陈述的集合，本质上来讲一个谓词就是一张数据表（table）；fact（事实）断言一个元组满足（数据表中的）某个关系。 Datalog 中的谓词用原子（atom）表示，atom 是 Datalog 中最基本的元素，其表示形式如下： 参数 terms 有两种形式： 变量（variable）：代表任意值，如 Age(person,age) 常量（constant）：表示特定值，如 Age(“Xiaoming”,18) atom 有两种类型： relation atom: P(X1,X2,…,Xn) arithmetic atom: age &gt;= 18 Datalog Rules (Logic) Rule 是表达逻辑推断的一种方式，也能用来说明如何推断 fact，rule 的格式如下： 注：逗号（,）可以理解为逻辑与 根据 Datalog Rules 枚举 body 中所有关系表达式的可能取值组合，进而得到新的 predicate/table。 EDB and IDB Predicates Datalog 谓词分为两类： EDB (Extensional DataBase) 在程序运行前已经定义 不可变 可以看做 input IDB (Intensional DataBase) 由规则推导出来 可以看做 output 例如：H &lt;- B1,B2,...,Bn.，H 只能是 IDB，Bi 可以是 EDB 或者 IDB。 Logical Or Negation Recursion Rule Safety 思考以下两条 rules 是否是安全的？ A(x) &lt;- B(y), x &gt; y.A(x) &lt;- B(y), !C(x, y). 对于第一条 rule，由于 B(y) 原子是有限的，满足该原子的 y 也是有限的，而满足 x&gt;y 的 x 有无穷多个，因此 A(x) 是无限的；第二条 rule 同理，因此这两条规则都是不安全的。在 Datalog 中只接受安全的 rules。 如果 rule 中每个变量至少在一个 non-negated relational atom 中出现一次，那么这个 rule 就是安全的。 再看一条 rule： A(x) &lt;- B(x), !A(x) 对于 subgoal A(x)，如果 A(x) 为 true，那么推导出来的 head A(x) 为 false；如果 subgoal A(x) 为 false，那么推导出来的 head A(x) 为 true。因此这条规则是矛盾的而且没有任何意义。 在 Datalog 的 atom 中，recursion 和 negation 必须要分开，不能在同一个 atom 中出现。 Execution of Datalog Programs Datalog 的两大重要特性： Monotonicity：因为 fact 是不会被删除的。（fact 的数量有限且确定） Termination：一个 Datalog 程序必然会终止的，因为 Datalog 具有单调性，且推断出的 IDB 的值也是有限的（Rule safety）。 Pointer Analysis via Datalog 了解了 Datalog 的基本语法和性质，我们就可以用它来实现声明式的指针分析算法。其中三个重要的部分对应如下： EDB：从程序的语义分析中提取出和指针相关的信息 IDB：指针分析的结果 Rules：指针分析的规则 Datalog Model for Point Analysis An Example Datalog Rules for Point Analysis An Example Taint Analysis via Datalog","categories":[{"name":"Program Analysis","slug":"Program-Analysis","permalink":"https://car0ta.github.io/categories/Program-Analysis/"}],"tags":[{"name":"Static Program Analysis","slug":"Static-Program-Analysis","permalink":"https://car0ta.github.io/tags/Static-Program-Analysis/"}]},{"title":"Static Program Analysis (Security)","slug":"Static-Program-Analysis-Security","date":"2022-05-20T10:55:54.000Z","updated":"2022-05-21T07:25:15.359Z","comments":true,"path":"2022/05/20/Static-Program-Analysis-Security/","link":"","permalink":"https://car0ta.github.io/2022/05/20/Static-Program-Analysis-Security/","excerpt":"","text":"在软件安全领域有两类非常常见且重要的漏洞是注入型漏洞（injection）和信息泄露（Information leaks），这两类漏洞的本质都是信息流（Information flow）问题，而解决信息流安全问题的一种方案就是污点分析技术（Taint Analysis）。 Information Flow Security Access Control vs. Information Flow Security： Access Control（保护敏感数据的标准方法） 检查程序是否有获取敏感数据的相应权限 关注信息是如何被访问的（accessed） Information Flow Security（end-to-end） 跟踪信息在程序中的流动以保证程序安全地处理信息 关注信息是如何被传播的（propagated） Information Flow If the information in variable xxx is transferred to variable yyy, then there is information flow x→yx\\rightarrow yx→y. 例如下面的例子，可以看出信息流分析和之前的指针分析有些类似。 Information Flow Security 将信息流和安全进行关联： 将程序中的变量分为不同的安全等级（security level） 在这些等级之间限定允许的信息流向，如 Information flow policy Security Level (Classes) 最基础的模型是 two-level policy，变量被分为两类等级： H：high security，机密信息 L：low security，公开信息 Security levels 可以建模为格（lattice）：L≤HL\\leq HL≤H 还有一些更为复杂的 security level 划分： Information Flow Policy 一种常见的策略是 Noninterference policy 高密级信息不能影响到低密级信息 保证攻击者无法通过观测低密级信息来推测出高密级信息 Confidentiality and Integrity Confidentiality（机密性） 防止秘密信息被泄露（上节中的内容都是为了保证机密性） 信息泄露类漏洞就是违反了机密性 Integrity（完整性） 防止重要信息被不可信的信息所污染 注入类漏洞就是违反了完整性 典型的注入类漏洞有命令注入，SQL 注入，XSS 攻击等 Confidentiality vs. Integrity Integrity 更加广泛的定义是（在信息流安全之外的定义）保证数据的准确性，完整性和一致性 Maintenance and the assurance of the accuracy, completeness, consistency of data: Accuracy: E.g., for information flow integrity, the (trusted) critical data should not be corrupted by untrusted data Completeness E.g., a database system should store all data completely Consistency E.g., a file transfer system should ensure that the file contents of both ends (sender and receiver) are identical Explicit Flows and Convert Channels Explicit Flows：直接通过赋值传递信息 Convert/Hidden Channels：隐蔽信道则不通过直接的信息传输 然而，隐蔽信道影响的数据量很有限，因此接下来针对显式流进行分析。 Taint Analysis Introduction 污点分析是一种最常用的信息流分析技术，它将程序中的数据分为两类：tainted data 和 untainted data。 Source：污点传播源，如函数的返回值，可控的外部输入等； Sink：污点汇聚点，如敏感函数。 污点分析就是追踪 source 点的数据是否会流到 sink 点中。 污点分析的两类应用： Taint and Pointer Analysis 污点分析和指针分析非常类似： The essence of taint analysis/pointer analysis is to track how tainted data/abstract objects flow through the program. 因此我们可以借助指针分析实现污点分析： 将污点数据（tainted data）看做特殊的 objects 将污点传播源（source）看做 objects 的创建点（allocation site） 借助指针分析传播污点数据 为了简单理解这里采用上下文不敏感的指针分析来实现污点分析： Domains Inputs &amp; Outputs Rules 和指针分析中的规则相同： 不同的是需要额外处理 source 点和 sink 点： Example 注意这里介绍的是最简单的污点分析，主要关注污点分析的核心思想。但真实情况要复杂得多，需要额外处理一些语句和方法，比如 sanitizers（污点消除点）。更为详细的污点分析介绍可见这篇文章。","categories":[{"name":"Program Analysis","slug":"Program-Analysis","permalink":"https://car0ta.github.io/categories/Program-Analysis/"}],"tags":[{"name":"Static Program Analysis","slug":"Static-Program-Analysis","permalink":"https://car0ta.github.io/tags/Static-Program-Analysis/"}]},{"title":"Static Program Analysis (Pointer Analysis-Context Sensitivity)","slug":"Static-Program-Analysis-Pointer-Analysis-Context-Sensitivity","date":"2022-05-18T15:11:47.000Z","updated":"2022-05-22T08:53:44.872Z","comments":true,"path":"2022/05/18/Static-Program-Analysis-Pointer-Analysis-Context-Sensitivity/","link":"","permalink":"https://car0ta.github.io/2022/05/18/Static-Program-Analysis-Pointer-Analysis-Context-Sensitivity/","excerpt":"","text":"Motivation 之前学习指针分析都是上下文不敏感（Context-Insensitive）的指针分析，但是它的问题就是不精确。 考虑使用上下文不敏感的指针分析：对于变量 i，由于 x.get()x.get()x.get() 存在 2 个 call targets，因此 i 的值可能是1也可能是2，所以结果是 i=NAC。然而显然实际运行时 i=1，从而造成分析错误。 考虑使用上下文敏感的指针分析：对于 id() 方法的两次调用分别维护不同的上下文信息，从而精确地得到 i=1。 Introduction C.I. vs C.S. Context Insensitivity (C.I.) 在动态执行时，一个方法可能被不同的调用上下文（calling context）调用多次 不同的调用上下文被混合并传播给程序的其他部分，从而产生假的数据流 Context Sensitivity (C.S.) 上下文敏感分析通过区分不同上下文的数据流对调用上下文进行建模，从而提高精度 非常知名的一个上下文敏感策略叫做 call-site (call-string) sensitivity，即方法的每个上下文是一条 call-site 链 Cloning-Based Context Sensitivity Cloning-Based 是实现上下文敏感的指针分析的最简单的方法 对于每一个方法，每到新的上下文就克隆一份新的方法和变量 Context-Sensitive Heap 在实际应用中，为了提高指针分析的精确性，上下文敏感技术也要应用到堆抽象中 堆抽象后的对象也作为一种上下文（heap contexts），通常从这类对象被创建的方法里继承上下文 Context-sensitive heap abstraction 要比 allocation-site abstraction 更加细粒度 为什么上下文敏感的堆抽象技术能提高精度？ 在动态执行过程中，一个创建点（allocation site）在不同的调用上下文（calling context）中可能会创建多个对象； 同一创建点下的不同对象会有不同的数据流，如果没有 heap contexts 则会合并这些数据流，从而损失精度。 🌰 需要注意的是，variable 和 heap 的上下文敏感二者结合才能提升精度，单独的 context-sensitive heap 不能提升精度。 Context Sensitive Pointer Analysis: Rules Domains 在上下文敏感的指针分析中，程序中的各类元素都被上下文限定： Rules: Without Call Rule: Call 上下文敏感实际记录了函数调用栈（上下文），而上下文不敏感在进入 callee 后就无法知道 caller 的信息。 Context Sensitive Pointer Analysis: Algorithms Pointer Flow Graph with C.S. 实现 context-sensitive pointer analysis 与 context-insensitive pointer analysis 类似，只是在 PFG 中加入了上下文信息。 我们定义 PFG with C.S. 的节点和边： Pointer Flow Graph: Edges Pointer Flow Graph: Call C.S. Pointer Analysis: Algorithm 算法中 Propagate() 和 AddEdge() 函数与先前的 C.I. Pointer Analysis 分析中是完全相同的。 算法中最关键的就是 ProcessCall() 函数，其中 Select() 函数作用是选择具体的 callee 上下文，根据 Select() 函数的实现的不同导致 C.S. Pointer Analysis 的多种变种（见下一部分） Context Sensitivity Variants 根据 select() 函数实现的不同，C.S. Pointer Analysis 有三种： Call-Site Sensitivity Select(c,l,_)=[l′,…,l′′,l]where&nbsp;c=[l′,…,l′′]\\textcolor{red}{Select}(c,l,\\_)=[{\\color{red}{l',\\ldots,l''}},l ] \\\\ \\text{where }c=[\\textcolor{red}{l',\\ldots ,l''}] Select(c,l,_)=[l′,…,l′′,l]where&nbsp;c=[l′,…,l′′] 每一个上下文都是一个调用点的链（调用链） 对于每一个方法调用，将 caller context 和当前的 call site 一起作为 callee context 实际上是调用栈的抽象表示 也叫做 call-string sensitivity 或者 k-CFA 🌰 如果存在递归调用的情况，那么某个函数的上下文可能有无穷多个： k-limiting Context Abstraction 为了解决递归调用存在过多上下文的问题，我们将上下文的长度设置一个上界，记作 k： 每个上下文的调用链中只保存最后 k 个 call sites 在实际分析中 k 是一个很小的数，通常 &lt;=3 Method contexts（通常 k=2）和 heap contexts（通常 k=1）通常使用不同的 k k-Call-Site Sensitivity/k-CFA 1-call-site/1-CFA Select(_,l,_)=[l]\\textcolor{red}{Select}(\\_,l,\\_)=[l] \\\\ Select(_,l,_)=[l] 2-call-site/2-CFA Select(c,l,_)=[l′′,l]where&nbsp;c=[l′,l′′]\\textcolor{red}{Select}(c,l,\\_)=[\\textcolor{red}{l''},l] \\\\ \\text{where }c=[l',\\textcolor{red}{l''}] Select(c,l,_)=[l′′,l]where&nbsp;c=[l′,l′′] 🌰 1-call-site Object Sensitivity Select(_,_,c′:oi)=[oj,…,ok,oi]where&nbsp;c′=[l′,oj,…,ok]\\textcolor{red}{Select}(\\_,\\_,{\\bf{c':o_i}})=[\\textcolor{red}{o_j,\\ldots,o_k},o_i] \\\\ \\text{where }c'=[l',\\textcolor{red}{o_j,\\ldots,o_k}] Select(_,_,c′:oi​)=[oj​,…,ok​,oi​]where&nbsp;c′=[l′,oj​,…,ok​] 每一个上下文都是 abstract objects（用 allocation site 表示） 的一个链 对于一个方法调用，将 receiver objects 和它的 heap context 一起作为 callee context 区分不同对象上的数据流操作 也叫做 allocation-site sensitivity 🌰 1-object 1-call-site vs 1-object 从下图中分析可以看出，1-call-site 在这个代码示例中会产生误报（如果采用 2-call-site 则不会）。 从调用图中也可以看出区别： 但是 Object Sensitivity 不一定就比 Call-Site Sensitivity 要好，例如对于之前的代码示例，1-Object Sensitivity 会造成误报。 Call-Site vs. Object Sensitivity 理论上二者的精度无法比较的 但实际对于 OO 语言而言，Object Sensitivity 要优于 Call-Site Sensitivity 从真实的实验对比可以看出，Object Sensitivity 在效率和精度上都比 Call-Site Sensitivity 要更优。 Type Sensitivity Select(_,_,c′:oi)=[t′,…,t′′,InType(oi)]where&nbsp;c′=[t′,…,t′′]\\textcolor{red}{Select}(\\_,\\_,c':o_i)=[t',\\ldots,t'',\\textcolor{red}{InType}(o_i)] \\\\ \\text{where }c'=[t',\\ldots,t''] Select(_,_,c′:oi​)=[t′,…,t′′,InType(oi​)]where&nbsp;c′=[t′,…,t′′] 每一个上下文都是一个 type list 对于一个方法调用，将 receiver object 的创建点的类型及其 heap context 作为 callee context Type Sensitivity 是 Object Sensitivity 的一个更粗糙的抽象 对于如下代码对比 Type Sensitivity 和 Object Sensitivity： 从真实的实验对比可以得出结论： Precision: object &gt; type &gt; call-site Efficiency: type &gt; object &gt; call-site","categories":[{"name":"Program Analysis","slug":"Program-Analysis","permalink":"https://car0ta.github.io/categories/Program-Analysis/"}],"tags":[{"name":"Static Program Analysis","slug":"Static-Program-Analysis","permalink":"https://car0ta.github.io/tags/Static-Program-Analysis/"}]},{"title":"Static Program Analysis (Pointer Analysis-Foundations)","slug":"Static-Program-Analysis-Pointer-Analysis-Foundations","date":"2022-05-16T16:49:31.000Z","updated":"2022-05-22T06:06:12.472Z","comments":true,"path":"2022/05/17/Static-Program-Analysis-Pointer-Analysis-Foundations/","link":"","permalink":"https://car0ta.github.io/2022/05/17/Static-Program-Analysis-Pointer-Analysis-Foundations/","excerpt":"","text":"Pointer Analysis: Rules 首先介绍需要用到的定义： Variables: x, y∈Vx,\\,y\\in Vx,y∈V Fields: f, g∈Ff,\\,g\\in Ff,g∈F Objects: oi, oj∈Oo_i,\\,o_j\\in Ooi​,oj​∈O Instance fields: oi.f, oi.g∈O×Fo_i.f,\\,o_i.g\\in O\\times Foi​.f,oi​.g∈O×F Pointers: Pointer=V∪(O×F)\\mathrm{Pointer}=V\\cup (O\\times F)Pointer=V∪(O×F) Pointers-to relations: pt:Pointer→P(O)pt: \\mathrm{Pointer}\\rightarrow P(O)pt:Pointer→P(O) 其中： P(O)P(O)P(O) 表示 OOO 的幂集 pt(p)pt(p)pt(p) 表示指针 p 指向的对象集合 规则： Kind Statement Rule New i: x=new T()i:\\;x=new\\;T()i:x=newT() oi∈pt(x)\\frac{}{o_i\\in pt(x)}oi​∈pt(x)​ Assign x=yx=yx=y oi∈pt(y)oi∈pt(x)\\frac{o_i\\in pt(y)}{o_i\\in pt(x)}oi​∈pt(x)oi​∈pt(y)​ Store x.f=yx.f=yx.f=y oi∈pt(x), oj∈pt(y)oj∈pt(oi.f)\\frac{o_i\\in pt(x),\\,o_j\\in pt(y)}{o_j\\in pt(o_i.f)}oj​∈pt(oi​.f)oi​∈pt(x),oj​∈pt(y)​ Load y=x.fy=x.fy=x.f oi∈pt(x), oj∈pt(oi.f)oj∈pt(y)\\frac{o_i\\in pt(x),\\,o_j\\in pt(o_i.f)}{o_j\\in pt(y)}oj​∈pt(y)oi​∈pt(x),oj​∈pt(oi​.f)​ 注：ab\\frac{a}{b}ba​ 为推导符号，其中 aaa 是前提（premises），bbb 是结论（conclusion）。 采用图形的方式描述： How to Implement Pointer Analysis 指针分析就是在指针（variables&amp;fields）之间传播（propagate）指向关系，或者说指针分析就是在求解一系列指针的包含约束（inclusion constraints）条件。 Key to implementation: when pt(x)pt(x)pt(x) is changed, propagate the changed part to the related pointers of xxx. 我们采用一个 graph 来连接 related pointers，当 pt(x)pt(x)pt(x) 变化时，将 changed part 传播到 xxx 的后继。 Pointer Flow Graph (PFG) 程序的指针流图（Pointer Flow Analysis）是一个有向图，用来表示程序中所有对象在指针中的流向，我们定义指针流图的点和边： Nodes: Pointer=V∪(O×F)\\mathrm{Pointer}=V\\cup (O\\times F)Pointer=V∪(O×F) 一个节点 n 表示一个指针（变量或抽象对象的域/属性） Edges: Pointer×Pointer\\mathrm{Pointer}\\times\\mathrm{Pointer}Pointer×Pointer 一条边 x→yx\\rightarrow yx→y 表示指针 x 指向的对象也被指针 y 指向，即指针 x 指向的对象流向（may flow to）指针 y 🌰 假设 c 和 d 开始都指向 oio_ioi​，根据上述规则可以构建 PFG。当 b 指向的对象更新时，根据 PFG 需要传递到 e 中，因此指针分析转化为求解 PFG 上传递闭包（transition closure）的问题。 指针分析的整个过程，需要在构建 PFG 和在已有 PFG 上传播指向关系这两步之间不断交替循环，这两步也是相互依赖的。 Pointer Analysis: Algorithms Algorithm Solve() 为主函数，由于是流不敏感分析，所以输入 S 是程序语句的 Set，四个红框对应的是四种指针相关的语句——New、Assign、Store 和 Load；AddEdge() 为 PFG 加边函数；Propagate() 为指针传播函数。 Worklist（WL）包含需要处理的指针的指向信息，WL⊆⟨Pointer,P(O)⟩WL\\subseteq \\langle \\mathrm{Pointer},P(O)\\rangleWL⊆⟨Pointer,P(O)⟩。Worklist 中的每一项都是一个指针 n 和指向集合 pts 的对 ⟨n,pts⟩\\langle n,pts\\rangle⟨n,pts⟩，表示 ptsptspts 需要被传播到 pt(n)pt(n)pt(n) 中。E.g., [⟨x,{oi}⟩, ⟨y,{oj,ok}⟩, ⟨oj.f,{ol}⟩…][\\langle x,\\{o_i\\}\\rangle,\\,\\langle y,\\{o_j,o_k\\}\\rangle,\\,\\langle o_j.f,\\{o_l\\}\\rangle\\ldots][⟨x,{oi​}⟩,⟨y,{oj​,ok​}⟩,⟨oj​.f,{ol​}⟩…] Handling of New and Assign 首先初始化并添加 assign 边： 针对所有的 New 语句，将其指向关系添加到 WL 中 对于所有的 Assign 语句，在 PFG 中添加一条 y→xy\\rightarrow xy→x 的边 AddEdge() 函数解释如下： 然后处理 WL 中的每一项： 对于 ⟨n,pts⟩\\langle n,pts\\rangle⟨n,pts⟩，计算 ptsptspts 和 pt(n)pt(n)pt(n) 的差值 Δ\\DeltaΔ，也就是说只将ptsptspts 中 pt(n)pt(n)pt(n) 没有的指向添加进来 Propagate() 函数解释如下： Differential Propagation Q: 为什么算法中采用的是差值传播（Differential Propagation） Δ = pts – pt(n)Propagate(n, Δ) A: 在实际分析中，一个程序的指针数量可能非常巨大，如果将全部的 ptsptspts 传播到 pt(n)pt(n)pt(n) 中，会造成极大的冗余而影响效率，因此可以采用差值传播的方式避免传播和处理一些冗余的指向信息。例如 pt(n)pt(n)pt(n) 中已有的指向信息肯定在之前就已经传播给 n 的所有后继节点了，因此不需要再传播一次。 🌰 考虑下图的情况，在传播完 pt(a)pt(a)pt(a) 后需要传播 pt(b)pt(b)pt(b) 如果我们选择直接传播（Direct Propagation），可以发现 o1, o3o_1,\\;o_3o1​,o3​ 被重复传播，造成冗余。 而采用差值传播则只需要传播 o5o_5o5​，在实际分析中会大大减小开销。 Handling of Store and Load 对于 Store 语句（如 x.f=yx.f=yx.f=y，其中 oi∈pt(x)o_i\\in pt(x)oi​∈pt(x)）添加一条 y→oi.fy\\rightarrow o_i.fy→oi​.f 的边 对于 Load 语句（如 y=x.fy=x.fy=x.f，其中 oi∈pt(x)o_i\\in pt(x)oi​∈pt(x)）添加一条 oi.f→yo_i.f\\rightarrow yoi​.f→y 的边 Example 根据上述算法计算以下代码的 PFG b = new C();a = b;c = new C();c.f = a;d = c;c.f = d;e = d.f; 将所有的 New 语句（line1, line3）的指向关系添加到 WL 中； foreach i:x=new T()∈S doadd ⟨x,{oi}⟩ to&nbsp;WL\\begin{aligned} &amp;{\\bf{foreach}}\\;\\textcolor{blue}{i:x=new\\;T()}\\in S\\;{\\bf{do}} \\\\ &amp;\\quad\\text{add$\\;\\langle x,\\{o_i\\}\\rangle\\;$to WL} \\\\ \\end{aligned} ​foreachi:x=newT()∈Sdoadd⟨x,{oi​}⟩to&nbsp;WL​ WL: [⟨b,{o1}⟩,⟨c,{o3}⟩][\\langle b,\\{o_1\\}\\rangle,\\langle c,\\{o_3\\}\\rangle][⟨b,{o1​}⟩,⟨c,{o3​}⟩] PFG: NULL 对于所有的 Assign 语句（line2, line4）在 PFG 中添加边； foreach x=y∈S doAddEdge(y,x)\\begin{aligned} &amp;{\\bf{foreach}}\\;\\textcolor{blue}{x=y}\\in S\\;{\\bf{do}} \\\\ &amp;\\quad\\text{\\color{red}AddEdge}(y,x) \\\\ \\end{aligned} ​foreachx=y∈SdoAddEdge(y,x)​ WL: [⟨b,{o1}⟩,⟨c,{o3}⟩][\\langle b,\\{o_1\\}\\rangle,\\langle c,\\{o_3\\}\\rangle][⟨b,{o1​}⟩,⟨c,{o3​}⟩] PFG: graph RL b(\"b {}\")--&gt;a(\"a {}\") c(\"c {}\")--&gt;d(\"d {}\") 首先处理 WL 中的元素 ⟨b,{o1}⟩\\langle b,\\{o_1\\}\\rangle⟨b,{o1​}⟩ while&nbsp;WL&nbsp;is&nbsp;not&nbsp;empty&nbsp;doremove&nbsp;⟨n,pts⟩&nbsp;from&nbsp;WLΔ=pts−pt(n)Propagate(n,Δ)\\begin{aligned} &amp;\\bf{while}\\text{ WL is not empty }\\bf{do} \\\\ &amp;\\quad\\text{remove $\\langle n,pts\\rangle$ from WL} \\\\ &amp;\\quad\\Delta=pts-pt(n) \\\\ &amp;\\quad\\text{\\color{red}{Propagate}}(n,\\Delta) \\\\ \\end{aligned} ​while&nbsp;WL&nbsp;is&nbsp;not&nbsp;empty&nbsp;doremove&nbsp;⟨n,pts⟩&nbsp;from&nbsp;WLΔ=pts−pt(n)Propagate(n,Δ)​ WL: [⟨c,{o3}⟩,⟨a,{o1}⟩][\\langle c,\\{o_3\\}\\rangle,\\color{red}{\\langle a,\\{o_1\\}\\rangle}][⟨c,{o3​}⟩,⟨a,{o1​}⟩] PFG: graph RL b(\"b {&lt;font color=red&gt;o1&lt;/font&gt;}\")--&gt;a(\"a {}\") c(\"c {}\")--&gt;d(\"d {}\") 接着处理 WL 中的元素 ⟨c,{o3}⟩\\langle c,\\{o_3\\}\\rangle⟨c,{o3​}⟩ WL: [⟨a,{o1}⟩,⟨d,{o3}⟩][\\langle a,\\{o_1\\}\\rangle,\\color{red}{\\langle d,\\{o_3\\}\\rangle}][⟨a,{o1​}⟩,⟨d,{o3​}⟩] PFG: graph RL b(\"b {o1}\")--&gt;a(\"a {}\") c(\"c {&lt;font color=red&gt;o3&lt;/font&gt;}\")--&gt;d(\"d {}\") 由于 4 中处理的指针 c 存在内存操作语句（line4, line6），所以需要更新 c 的 instance field 相关的指向关系 if&nbsp;n&nbsp;represents&nbsp;a&nbsp;variable&nbsp;x&nbsp;thenforeach oi∈Δ doforeach x.f=y∈S doAddEdge(y,oi.f)foreach y=x.f∈S doAddEdge(oi.f,y)\\begin{aligned} &amp;\\bf{if}\\text{ n represents a variable x }\\bf{then} \\\\ &amp;\\quad{\\bf{foreach}}\\;o_i\\in\\Delta\\;{\\bf{do}} \\\\ &amp;\\quad\\quad{\\bf{foreach}}\\;\\textcolor{blue}{x.f=y}\\in S\\;{\\bf{do}} \\\\ &amp;\\quad\\quad\\quad\\text{\\color{red}{AddEdge}}(y,o_i.f) \\\\ &amp;\\quad\\quad{\\bf{foreach}}\\;\\textcolor{blue}{y=x.f}\\in S\\;{\\bf{do}} \\\\ &amp;\\quad\\quad\\quad\\text{\\color{red}{AddEdge}}(o_i.f,y) \\\\ \\end{aligned} ​if&nbsp;n&nbsp;represents&nbsp;a&nbsp;variable&nbsp;x&nbsp;thenforeachoi​∈Δdoforeachx.f=y∈SdoAddEdge(y,oi​.f)foreachy=x.f∈SdoAddEdge(oi​.f,y)​ WL: [⟨a,{o1}⟩,⟨d,{o3}⟩][\\langle a,\\{o_1\\}\\rangle,\\langle d,\\{o_3\\}\\rangle][⟨a,{o1​}⟩,⟨d,{o3​}⟩] PFG: graph RL b(\"b {o1}\")--&gt;a(\"a {}\") c(\"c {o3}\")--&gt;d(\"d {}\") a--&gt;e(\"o3.f {}\") d--&gt;e 处理 WL 中的元素 ⟨a,{o1}⟩\\langle a,\\{o_1\\}\\rangle⟨a,{o1​}⟩ WL: [⟨d,{o3}⟩,⟨o3.f,{o1}⟩][\\langle d,\\{o_3\\}\\rangle,\\color{red}{\\langle o_3.f,\\{o_1\\}\\rangle}][⟨d,{o3​}⟩,⟨o3​.f,{o1​}⟩] PFG: graph RL b(\"b {o1}\")--&gt;a(\"a {&lt;font color=red&gt;o1&lt;/font&gt;}\") c(\"c {o3}\")--&gt;d(\"d {}\") a--&gt;e(\"o3.f {}\") d--&gt;e 处理 WL 中的元素 ⟨d,{o3}⟩\\langle d,\\{o_3\\}\\rangle⟨d,{o3​}⟩，由于指针 d 存在内存操作语句，因此需要更新 d 的 instance field 相关的指向关系 WL: [⟨o3.f,{o1}⟩,⟨o3.f,{o3}⟩][\\langle o_3.f,\\{o_1\\}\\rangle,\\color{red}{\\langle o_3.f,\\{o_3\\}\\rangle}][⟨o3​.f,{o1​}⟩,⟨o3​.f,{o3​}⟩] PFG: graph RL b(\"b {o1}\")--&gt;a(\"a {o1}\") c(\"c {o3}\")--&gt;d(\"d {&lt;font color=red&gt;o3&lt;/font&gt;}\") a--&gt;e(\"o3.f {}\") d--&gt;e e--&gt;f(\"e {}\") 处理 WL 中的元素 ⟨o3.f,{o1}⟩\\langle o_3.f,\\{o_1\\}\\rangle⟨o3​.f,{o1​}⟩ WL: [⟨o3.f,{o3}⟩,⟨e,{o1}⟩][\\langle o_3.f,\\{o_3\\}\\rangle,\\color{red}{\\langle e,\\{o_1\\}\\rangle}][⟨o3​.f,{o3​}⟩,⟨e,{o1​}⟩] PFG: graph RL b(\"b {o1}\")--&gt;a(\"a {o1}\") c(\"c {o3}\")--&gt;d(\"d {o3}\") a--&gt;e(\"o3.f {&lt;font color=red&gt;o1&lt;/font&gt;}\") d--&gt;e e--&gt;f(\"e {}\") 处理 WL 中的元素 ⟨o3.f,{o3}⟩\\langle o_3.f,\\{o_3\\}\\rangle⟨o3​.f,{o3​}⟩ WL: [⟨e,{o1}⟩,⟨e,{o3}⟩][\\langle e,\\{o_1\\}\\rangle,\\color{red}{\\langle e,\\{o_3\\}\\rangle}][⟨e,{o1​}⟩,⟨e,{o3​}⟩] PFG: graph RL b(\"b {o1}\")--&gt;a(\"a {o1}\") c(\"c {o3}\")--&gt;d(\"d {o3}\") a--&gt;e(\"o3.f {o1, &lt;font color=red&gt;o3&lt;/font&gt;}\") d--&gt;e e--&gt;f(\"e {}\") 最后处理 WL 中的 ⟨e,{o1}⟩,⟨e,{o3}⟩\\langle e,\\{o_1\\}\\rangle,\\langle e,\\{o_3\\}\\rangle⟨e,{o1​}⟩,⟨e,{o3​}⟩ 得到最终的 PFG WL: [] PFG: graph RL b(\"b {o1}\")--&gt;a(\"a {o1}\") c(\"c {o3}\")--&gt;d(\"d {o3}\") a--&gt;e(\"o3.f {o1, o3}\") d--&gt;e e--&gt;f(\"e {&lt;font color=red&gt;o1, o3&lt;/font&gt;}\") Pointer Analysis with Method Calls 过程间的指针分析需要 call graph，先前的 CHA 是不精确的，而利用 Pointer Analysis 的结果构建 call graph 更加的精确。因为 call graph 的构建过程和指针分析的过程是同步进行的，因此这种构建 call graph 的方式又叫做 on-the-fly call graph construction。 Rule: Call Q：为什么不添加一条 x→mthisx\\rightarrow m_{this}x→mthis​ 的 PFG 边？ A：对于下面的例子，我们考虑有这条边和没有这条边的情况： with x→mthisx\\rightarrow m_{this}x→mthis​ without x→mthisx\\rightarrow m_{this}x→mthis​ Interprocedural Pointer Analysis Algorithm AddReachable ProcessCall Example 利用上述算法对如下代码进行 Interprocedural Pointer Analysis，构建 Call Graph 和 PFG。 class A { static void main() { A a = new A(); A b = new B(); A c = b.foo(a); } A foo(A x) { … } }class B extends A { A foo(A y) { A r = new A(); return r; }} 分析结果：","categories":[{"name":"Program Analysis","slug":"Program-Analysis","permalink":"https://car0ta.github.io/categories/Program-Analysis/"}],"tags":[{"name":"Static Program Analysis","slug":"Static-Program-Analysis","permalink":"https://car0ta.github.io/tags/Static-Program-Analysis/"}]},{"title":"Static Program Analysis (Pointer Analysis)","slug":"Static-Program-Analysis-Pointer-Analysis","date":"2022-05-16T08:07:24.000Z","updated":"2022-05-16T16:48:50.250Z","comments":true,"path":"2022/05/16/Static-Program-Analysis-Pointer-Analysis/","link":"","permalink":"https://car0ta.github.io/2022/05/16/Static-Program-Analysis-Pointer-Analysis/","excerpt":"","text":"Motivation CHA 只关注类的继承结构，对于上述代码 CHA 得到3个 call targets，其中有两个是误报（false positives），从而常量传播分析的结果是 x=NACx=\\textrm{NAC}x=NAC； 而指针分析（Pointer Analysis）基于指向关系（point-to relation），我们能够知道 n 实际指向的就是 new One() 得到的对象，从而常量传播分析的结果就是 x=1x=1x=1。 对比 CHA 和 Pointer Analysis 可以发现指针分析的结果更加精确！ Introduction to Pointer Analysis 指针分析计算一个指针实际指向的内存地址； 对于面向对象语言（object-oriented program）如 Java，指针分析计算一个指针（variable or field）实际指向的对象； 指针分析可以视为一个 may analysis，因此是 over-approximation。 🌰 指针分析和别名分析（Alias Analysis）相似但有区别： 指针分析：分析一个指针实际指向的对象 别名分析：分析两个或者多个指针是否指向同一个对象 别名信息能够通过指向关系进行推导得出。 指针分析的应用： 得到基础信息，如 call graph，aliases 编译器优化 Bug 检测，如空指针检测 安全分析，如信息流分析 Key Factors of Pointer Analysis 影响指针分析的四个要素： Factor Problem Choice Heap abstraction How to model heap memory? - Allocation-site- Storeless Context sensitivity How to model calling contexts? - Context-sensitive- Context-insensitive Flow sensitivity How to model control flow? - Flow-sensitive- Flow-insensitive Analysis scope Which parts of program should be analysed? - Whole-program- Demand-driven Heap Abstraction 在动态执行中，由于存在递归和循环，堆上的对象数量可能是无限的；为了确保指针分析能够终止，堆抽象技术将动态运行时无限数量的对象抽象为静态分析中有限数量的对象。 堆抽象技术主要有两大流派：Store-based model 和 Storeless model 这里介绍最为常用的堆抽象技术 Allocation-Site Abstraction： 根据 objects 的创建点（allocation site）对 objects 进行建模 为每个创建点创建一个 abstract object，它将代表动态运行时实际创建的所有对象 Context Sensitivity 在指针分析过程中针对调用上下文（calling contexts）的建模分为两种： Context-sensitive 区分一个方法不同的调用上下文，针对每个上下文分析一次。 Context-insensitive 合并一个方法的所有调用上下文，对每个方法只分析一次，可能会损失精度。 Flow Sensitivity 指针分析中控制流处理分为两种： Flow-sensitive 考虑程序中语句的执行顺序，对每一个程序点维护一个指向关系的 map。 Flow-insensitive 忽略程序中语句的执行顺序，对整个程序只维护一个指向关系的 map。 如上图，流敏感（蓝色）对每个程序点都有一个指向关系的 map，而流不敏感（橘色）只保存全局一个指向关系的 map，因此有可能误报。 之前课程的数据流分析都是流敏感的，而在 Java 这类 OOP 语言的指针分析中，Flow-sensitive 未必就比 Flow-insensitive 要更好，因此接下来主要介绍 Flow-sensitive 的指针分析（更常用）。 Analysis Scope 指针分析可以分析全程序的所有指针信息，也可以分析部分代码的指针信息： Whole-program 分析程序中所有指针的指向关系，分析结果可供所有应用使用。 Demand-driven 根据需求只分析程序中部分指针（special site of interest）的指向关系，分析结果只能满足特定的应用。 需要先找到 special site of interest，然后进行分析，因此时间复杂度可能更高。 Concerned Statements 现代语言中有许多种类的语句（statement）： if-else switch-case for/while/do-while break/continue … 但上述语句都不会影响指针的指向，因此在指针分析中通常会忽略，而只是关注那些影响指针指向的语句（pointer-affecting statements）。 Pointers in Java Local variable: x Static field (global variable): C.f 可视为 Local variable 处理 Instance field: x.f Array element: array[i] 静态分析无法计算数组每个下标具体的指向关系（如数组下标为变量时），通常做法是将其建模为 single field，记作 arr，它指向所有存储在数组中的值。 可视为 Instance field 处理 Pointer-Affecting Statements New: x=new T()x=new\\;T()x=newT() Assign: x=yx=yx=y Store: x.f=yx.f=yx.f=y Load: y=x.fy=x.fy=x.f Call: r=x.k(a,…)r=x.k(a,\\ldots)r=x.k(a,…) 对于复杂的内存操作语句（Store/Load）通常会引入临时变量将其转换为三地址码进行分析。 对于方法调用（Call）语句，存在三种调用类型： Static call: C.foo() Special call: super.foo(), x.&lt;init&gt;(), this.privateFoo() Virtual call: x.foo() 其中最复杂的是 virtual call，因为存在多态所以可能会有多个被调方法，而 static call 和 special call 只会有一个确定的被调方法。因此接下来主要关注 virtual call。","categories":[{"name":"Program Analysis","slug":"Program-Analysis","permalink":"https://car0ta.github.io/categories/Program-Analysis/"}],"tags":[{"name":"Static Program Analysis","slug":"Static-Program-Analysis","permalink":"https://car0ta.github.io/tags/Static-Program-Analysis/"}]},{"title":"Static Program Analysis (Interprocedural Analysis)","slug":"Static-Program-Analysis-Interprocedural-Analysis","date":"2022-05-11T09:15:14.000Z","updated":"2022-05-18T14:54:18.151Z","comments":true,"path":"2022/05/11/Static-Program-Analysis-Interprocedural-Analysis/","link":"","permalink":"https://car0ta.github.io/2022/05/11/Static-Program-Analysis-Interprocedural-Analysis/","excerpt":"","text":"Motivation 之前学习的各类分析问题都是过程内分析（Intraprocedural Analysis），不涉及到过程间的方法调用。在过程间分析中如果遇到方法调用通常是做最保守的假设，因此会损失精度（大量误报）。 考虑下图中的常量传播分析，采用过程内分析得到的是 x=NAC, y=NAC, n=NAC，而实际上 x=42, y=43, n=10。 为了提高精度，我们需要引入过程间分析（Interprocedural Analysis）：通过过程间控制流的边（Interprocedural Control-Flow edges, i.e., call and return edges）传递数据流信息。 为了实现过程间分析，我们需要构建调用图（call graph）。 Call Graph Construction (CHA) Call Graph 调用图（call graph）代表程序中方法之间的调用关系。换句话说，call graph 是程序中调用边（call edge）的集合，调用边从调用点（call-site）出发到被调函数（callee）。 call graph 的应用： 过程间分析的基础 程序优化、理解、调试、测试等 调用图构造算法： Class hierarchy analysis (CHA) Rapid type analysis (RTA) Variable type analysis (VTA) Pointer analysis (k-CFA) 从上往下分析越来越精确，但效率越来越低。 Method Calls in Java static call special call virtual call 指令 invokestatic invokespecial invokeinterfaceinvokevirtual 是否需要实例化对象 N Y Y 被调方法 静态方法 构造函数私有实例方法父类实例方法 其他实例方法 被调方法个数 1 1 &gt;=1 (多态) 被调方法确定时机 编译时 编译时 运行时 构造调用图的关键在于如何处理 virtual call？ Method Dispatch of Virtual Calls 在运行时，一个虚调用 o1.foo(… )2o^1.foo(\\dots)^2o1.foo(…)2 根据两点来确定具体调用哪个方法： 调用者实例对象类型（即 o 的类型），记为 c 调用点的函数签名，记为 m 方法签名能够唯一标识一个方法，它包括类名、方法名和方法描述符，方法描述符又包括参数类型和返回值类型 Java 中 Dispatch 机制决定运行时具体调用哪个方法，我们定义函数 Dispatch(c,m)Dispatch(c, m)Dispatch(c,m)： Dispatch(c,m)={m′if&nbsp;c&nbsp;contains&nbsp;non-abstract&nbsp;method&nbsp;m′&nbsp;thathas&nbsp;the&nbsp;same&nbsp;name&nbsp;and&nbsp;descriptor&nbsp;as&nbsp;mDispatch(c′,m)otherwisewhere&nbsp;c′&nbsp;is&nbsp;superclass&nbsp;of&nbsp;cDispatch(c,m)=\\begin{cases} m'&amp;\\text{if c contains non-abstract method $m'$ that}\\\\ &amp;\\text{has the same name and descriptor as m} \\\\ Dispatch(c',m) &amp; otherwise \\end{cases} \\\\ \\text{where $c'$ is superclass of $c$} Dispatch(c,m)=⎩⎨⎧​m′Dispatch(c′,m)​if&nbsp;c&nbsp;contains&nbsp;non-abstract&nbsp;method&nbsp;m′&nbsp;thathas&nbsp;the&nbsp;same&nbsp;name&nbsp;and&nbsp;descriptor&nbsp;as&nbsp;motherwise​where&nbsp;c′&nbsp;is&nbsp;superclass&nbsp;of&nbsp;c 如果在类 c 当中存在一个和 m 的方法名和描述符都相同的非抽象方法 m′m'm′，那么调用该方法，否则递归父类查找。 🌰 Dispatch(B,A.foo())=A.foo()Dispatch(C,A.foo())=C.foo()Dispatch(B, A.foo())=A.foo() \\\\ Dispatch(C, A.foo())=C.foo() Dispatch(B,A.foo())=A.foo()Dispatch(C,A.foo())=C.foo() Class Hierarchy Analysis (CHA) 类继承分析（CHA）通过查找类的继承结构来确定具体的被调方法： 需要整个程序中类的继承信息（继承结构） 根据调用点的接收变量（receiver variable）的声明类型来解析 virtual call（下面代码中的 a 就是接收变量） A a=…;a.foo();\\begin{aligned} &amp;A\\;a=\\ldots; \\\\ &amp;\\textcolor{red}{a}.foo(); \\end{aligned} ​Aa=…;a.foo();​ 假设接收变量 a 可以指向 A 类及 A 的所有子类的对象 Call Resolution of CHA 我们定义函数 Resolve(cs)Resolve(cs)Resolve(cs) 来分析调用点 cs 处可能的目标方法，具体算法如下： 如果 cs 是 static call，直接将该方法签名加入集合 T 如果 cs 是 special call，取方法 m 的类 cmc^mcm 并调用 Dispatch 函数，将结果加入集合 T 构造函数（Constructor） 私有实例方法（private instance method） 父类实例方法（Superclass instance method） 如果 cs 是 virtual call，取 cs 处接收变量的声明类型 c，遍历 c 及 c 的所有子类并调用 Dispatch 函数，将结果加入集合 T 🌰 CHA 只考虑调用点处接收变量的声明类型去分析目标方法，即使实际 new 了一个 B 类，依然会产生两个误报 C.foo() 和 D.foo() CHA 的特征： Advantage: fast 仅考虑 call-site 处接收变量的声明类型及其类的继承结构，而忽略了数据流和控制流信息。 Disadvantage: imprecise 容易产生大量误报 CHA 的应用：IDE（如 Intellij IDEA） Call Graph Construction 通过 CHA 构建整个程序的 call graph： 从入口方法开始（main method） 对于每一个可达方法 m，通过 CHA 算法分析一个调用点的目标方法 重复以上步骤直到没有可达的新方法 具体算法： WL 即 WorkList，记录需要处理的 methods CG 即 call graph，是 call edges 的集合 RM 即 Reachable Method，记录已经处理的 methods 🌰 Interprocedural Control-Flow Graph CFG 表示单个 method 控制流关系 ICFG 表示整个程序的控制流关系（借助 ICFG 我们可以实现过程间分析） 一个程序的 ICFG 包括程序中所有方法的 CFG，以及两种额外边： Call edges：从调用点（call-sites）出发到被调函数（callees）的 entry 节点 return edges：从被调函数的返回语句（return statements）到调用点的下一条语句（return sites） 我们可以理解为 ICFG = CFGs + call &amp; return edges，而如何在 CFG 的基础上添加 call edges 和 return edges 就需要用到上文中构建的 call graph。 🌰 Interprocedural Data-Flow Analysis 过程间数据流分析即在 ICFG 的基础上对程序进行数据流分析，与过程内数据流分析对比如下： Intraprocedural Interprocedural Program representation CFG ICFG = CFGs + call &amp; return edges Transfer functions Node transfer Node transfer + edge transfer Edge transfer 包括： call edge transfer：从 call node 到 callee 的 entry node 传递数据流（传参数） return edge transfer：从return node 到 return site 传递数据流（传返回值） 🌰：Interprocedural Constant Propagation（过程间常量传播分析） Call edge transfer: pass argument values Return edge transfer: pass return values Node transfer: 和 Intraprocedural Constant Propagation 相似，但对于每一个 call node，需要 kill 掉 LHS(Left Hand Side) variable 分析结果： Q：为什么要保留从 call site 到 return site 的边（call-to-return edge）？ A：call-to-return edge 能够在方法内传递本地数据流，如果没有这条边则需要当前方法内的上下文变量传递到被调函数，这是非常低效的！ 假如是 Intraprocedural Constant Propagation（过程内常量传播分析），其分析结果为： 显然过程间分析要比过程内分析更加精确！","categories":[{"name":"Program Analysis","slug":"Program-Analysis","permalink":"https://car0ta.github.io/categories/Program-Analysis/"}],"tags":[{"name":"Static Program Analysis","slug":"Static-Program-Analysis","permalink":"https://car0ta.github.io/tags/Static-Program-Analysis/"}]},{"title":"Static Program Analysis (Data Flow Analysis-Foundations)","slug":"Static-Program-Analysis-Data-Flow-Analysis-Foundations","date":"2022-05-06T07:15:23.000Z","updated":"2022-05-14T15:26:43.872Z","comments":true,"path":"2022/05/06/Static-Program-Analysis-Data-Flow-Analysis-Foundations/","link":"","permalink":"https://car0ta.github.io/2022/05/06/Static-Program-Analysis-Data-Flow-Analysis-Foundations/","excerpt":"","text":"Iterative Algorithm 对于一个含有 k 个节点的 CFG（program），迭代算法会在每次迭代时更新每个节点 n 的 OUT[n]。 假设数据流分析的值域为 V，那么我们可以定义一个 k 元组： (OUT[n1], OUT[n2], …, OUT[nk])∈(V1×V2×…×Vk)=Vk(OUT[{n}_{1}],\\, OUT[{n}_{2}],\\, \\ldots,\\, OUT[{n}_{k}])\\in({V}_{1}\\times{V}_{2}\\times\\ldots\\times{V}_{k})={V}^{k} (OUT[n1​],OUT[n2​],…,OUT[nk​])∈(V1​×V2​×…×Vk​)=Vk 每个 k 元组代表每次迭代后的值。 每次迭代通过 transfer functions 和 control-flow handling 来更新 Vk{V}^{k}Vk，这个过程可以抽象为一个函数 F:Vk→VkF: {V}^{k}\\rightarrow{V}^{k}F:Vk→Vk。 当迭代算法输出的 k 元组和上一次相同时，迭代结束，算法停止；即当 X=F(X)X=F(X)X=F(X) 时，X是函数 F 的一个不动点，我们说此时迭代算法达到不动点，算法停止。 迭代算法为数据流分析提供一个 solution，此时会有以下几个问题： 算法是否总会到达不动点，或者说是否总有 solution？ 只有一个不动点（solution）吗？这个 solution 是最好的（最精确）吗？ 什么时候算法会到达不动点？ Partial Order 我们定义偏序集（poset）为一个 (P, ⊑)(P,\\, \\sqsubseteq)(P,⊑) 对，其中 P 为一个偏序集合，⊑\\sqsubseteq⊑ 为 P 上的偏序关系。它满足以下性质： （1）∀x∈P, x⊑x\\forall x\\in P,\\,x\\sqsubseteq x∀x∈P,x⊑x （Reflexivity，自反性） （2）∀x, y∈P, x⊑y ∧ y⊑x⇒x=y\\forall x,\\,y\\in P,\\,x\\sqsubseteq y\\,\\wedge\\,y\\sqsubseteq x\\Rightarrow x=y∀x,y∈P,x⊑y∧y⊑x⇒x=y （Antisymmetry，反对称性） （3）∀x, y, z∈P, x⊑y ∧ y⊑z⇒x⊑z\\forall x,\\,y,\\,z\\in P,\\,x\\sqsubseteq y\\,\\wedge\\,y\\sqsubseteq z\\Rightarrow x\\sqsubseteq z∀x,y,z∈P,x⊑y∧y⊑z⇒x⊑z （Transitivity，传递性） 偏序（partial）关系不保证集合 P 中的任意两个元素都可以进行比较，全序关系能保证任意两个元素都可以比较。例如下图中的 substring 集合满足偏序关系，但是 pin 和 sin 字符串并不满足子串关系。 Upper and Lower Bounds 给定一个偏序集 (P, ⊑)(P,\\, \\sqsubseteq)(P,⊑) 和它的一个子集 S，S⊆PS\\subseteq PS⊆P： 如果 ∃u∈P, ∀x∈S, x⊑u\\exists u\\in P,\\,\\forall x\\in S,\\,x\\sqsubseteq u∃u∈P,∀x∈S,x⊑u，那么 u 是 S 的一个上界（upper bound）； 如果 ∃l∈P, ∀x∈S, l⊑x\\exists l\\in P,\\,\\forall x\\in S,\\,l\\sqsubseteq x∃l∈P,∀x∈S,l⊑x，那么 l 是 S 的一个下界（lower bound）。 将偏序集 S 的最小上界（least upper bound, lub or join）记为 ⊔S\\sqcup S⊔S，它对于偏序集 S 中的每个上界 u 都有 ⊔S⊑u\\sqcup S \\sqsubseteq u⊔S⊑u； 将偏序集 S 的最大下界（greater lower bound, glb or meet）记为 ⊓S\\sqcap S⊓S，它对于偏序集 S 中的每个下界 l 都有 l⊑⊓Sl\\sqsubseteq \\sqcap Sl⊑⊓S。 特别地，如果偏序集 S 只有两个元素 a 和 b（S={a, b}），那么： 最小上界 ⊔S\\sqcup S⊔S 可以记为 a⊔ba\\sqcup ba⊔b（the join of a and b）； 最大下界 ⊓S\\sqcap S⊓S 可以记为 a⊓ba\\sqcap ba⊓b（the meet of a and b）。 一些性质： 不是每个偏序集都有 lub 或者 glb 如果一个偏序集有 lub 或者 glb，那么它一定是唯一的 Lattice, Semilattice, Complete and Product Lattice Lattice (格) Given a poset (P, ⊑)(P,\\,\\sqsubseteq)(P,⊑), ∀a, b∈P\\forall a,\\,b\\in P∀a,b∈P, if a⊔ba\\sqcup ba⊔b and a⊓ba\\sqcap ba⊓b exist, then (P, ⊑)(P,\\,\\sqsubseteq)(P,⊑) is called a lattice. 如果一个偏序集中的每两个元素都有最小上界和最大下界，那么这个偏序集是一个格。 Semilattice (半格) Given a poset (P, ⊑)(P,\\,\\sqsubseteq)(P,⊑), ∀a, b∈P\\forall a,\\,b\\in P∀a,b∈P, if only a⊔ba\\sqcup ba⊔b exists, then (P, ⊑)(P,\\,\\sqsubseteq)(P,⊑) is called a join semilattice, if only a⊓ba\\sqcap ba⊓b exists, then (P, ⊑)(P,\\,\\sqsubseteq)(P,⊑) is called a meet semilattice. Complete Lattice (全格) Given a poset (P, ⊑)(P,\\,\\sqsubseteq)(P,⊑), for arbitrary subset S of P, if ⊔S\\sqcup S⊔S and ⊓S\\sqcap S⊓S exist, then (P, ⊑)(P,\\,\\sqsubseteq)(P,⊑) is called a complete lattice. 如果一个偏序集的所有子集都有最小上界和最大下界，那么这个偏序集是一个全格。 每一个全格 (P, ⊑)(P,\\,\\sqsubseteq)(P,⊑) 都有一个最大元素 ⊤=⊔P\\top =\\sqcup P⊤=⊔P（称为 top）和一个最小元素 ⊥=⊓P\\bot =\\sqcap P⊥=⊓P（称为 bottom）。 如果一个格是有穷的（元素有限的，finite lattice），那么它一定是全格；但 complete lattice 不一定是 finite lattice。 数据流分析更加关注 complete lattice！ Product Lattice (格积) Given lattices L1=(P1, ⊑1), L2=(P2, ⊑2), …, Ln=(Pn, ⊑n){L}_{1}=({P}_{1},\\,{\\sqsubseteq}_{1}),\\,{L}_{2}=({P}_{2},\\,{\\sqsubseteq}_{2}),\\,\\dots,\\,{L}_{n}=({P}_{n},\\,{\\sqsubseteq}_{n})L1​=(P1​,⊑1​),L2​=(P2​,⊑2​),…,Ln​=(Pn​,⊑n​), if for all i, (Pi, ⊑i)({P}_{i},\\,{\\sqsubseteq}_{i})(Pi​,⊑i​) has ⊔i\\sqcup_i⊔i​ (leaster upper bound) and ⊓i\\sqcap_i⊓i​ (greatest lower bound), then we can have a product lattice Ln=(P,⊑)L^n=(P, \\sqsubseteq)Ln=(P,⊑) that is defined by: P=P1×…×Pn(x1, …, xn)⊑(y1, …, yn)⇔(x1⊑y1)∧…∧(xn⊑yn)(x1, …, xn)⊔(y1, …, yn)=(x1⊔1y1, …, xn⊔nyn)(x1, …, xn)⊓(y1, …, yn)=(x1⊓1y1, …, xn⊓nyn)\\begin{aligned} &amp;P=P_1\\times\\ldots\\times P_n \\\\ &amp;(x_1,\\,\\ldots,\\,x_n)\\sqsubseteq(y_1,\\,\\ldots,\\,y_n)\\Leftrightarrow(x_1\\sqsubseteq y_1)\\wedge\\ldots\\wedge(x_n\\sqsubseteq y_n) \\\\ &amp;(x_1,\\,\\ldots,\\,x_n)\\sqcup(y_1,\\,\\ldots,\\,y_n)=(x_1\\sqcup_1 y_1,\\,\\ldots,\\,x_n\\sqcup_n y_n) \\\\ &amp;(x_1,\\,\\ldots,\\,x_n)\\sqcap(y_1,\\,\\ldots,\\,y_n)=(x_1\\sqcap_1 y_1,\\,\\ldots,\\,x_n\\sqcap_n y_n) \\end{aligned} ​P=P1​×…×Pn​(x1​,…,xn​)⊑(y1​,…,yn​)⇔(x1​⊑y1​)∧…∧(xn​⊑yn​)(x1​,…,xn​)⊔(y1​,…,yn​)=(x1​⊔1​y1​,…,xn​⊔n​yn​)(x1​,…,xn​)⊓(y1​,…,yn​)=(x1​⊓1​y1​,…,xn​⊓n​yn​)​ product lattice 也是一个 lattice 如果一个 product lattice L 是全格的积，那么 L 也是全格 Data Flow Analysis Framework via Lattice 一个数据流分析框架 (D, L, F) 由以下元素组成： D: a direction of data flow，forward or backward L: a lattice including domain of the values V and a meet ⊓\\sqcap⊓ or join sqcupsqcupsqcup operator F: a family of transfer functions from V to V 数据流分析可以视为在 lattice 的值上迭代地应用 转换函数和 meet/join 操作符。 Monotonicity and Fixed Point Theorem Monotonicity (单调性) A function f: L→Lf:\\,L\\to Lf:L→L (L is a lattice) is monotonic if ∀x, y∈L, x⊑y⇒f(x)⊑f(y)\\forall x,\\,y\\in L,\\,x\\sqsubseteq y \\Rightarrow f(x)\\sqsubseteq f(y)∀x,y∈L,x⊑y⇒f(x)⊑f(y) Fixed Point Theorem (不动点定理) Given a complete lattice (L, ⊑)(L,\\,\\sqsubseteq)(L,⊑), if (1) f: L→Lf:\\,L\\to Lf:L→L is monotonic and (2) L is finite, then the least fixed point of f can be found by iterating f(⊥), f(f(⊥)), fk(⊥)f(\\bot),\\,f(f(\\bot)),\\,f^k(\\bot)f(⊥),f(f(⊥)),fk(⊥) until a fixed point reached the greatest fixed point of f can be found by iterating f(⊤), f(f(⊤)), fk(⊤)f(\\top),\\,f(f(\\top)),\\,f^k(\\top)f(⊤),f(f(⊤)),fk(⊤) until a fixed point reached 证明略 Relate Iterative Algorithm to Fixed Point Theorem 证明 function F is monotonic 省略 什么时候迭代算法到达不动点？ The height of a lattice hhh is the length of the longest path from Top to Bottom in the lattice. lattice 的高度定义为从 Top 到 Bottom 的最长路径的长度，假设 lattice 的高度为h，CFG 的节点数为 k，假设每次迭代只能让一个节点在 lattice 增长一个高度，那么最坏情况下迭代次数为 i=h∗ki=h*ki=h∗k。 May/Must Analysis, A Lattice View MOP and Distributivity Meet-Over-All-Paths Solution (MOP) 之前的数据流分析算法（Iterative Algorithm）是流敏感的，而 MOP 是路径敏感的。 Ours (Iterative Algorithm) vs. MOP IN[S4]=OUT[S3]=fS3(IN[S3])=fS3(OUT[S1] ⊔ OUT[S2])=fS3(fS1(IN[S1]) ⊔ fS2(IN[S2]))=fS3(fS1(OUT[Entry]) ⊔ fS2(OUT[Entry]))MOP[S4]=fS3(fS1(OUT[Entry])) ⊔ fS3(fS2(OUT[Entry]))⇒Ours=F(x⊔y)MOP=F(x)⊔F(y)\\begin{aligned} \\begin{aligned} \\textcolor{blue}{IN[S_4]}&amp;=OUT[S_3] \\\\ &amp;=f_{S_3}(IN[S_3]) \\\\ &amp;=f_{S_3}(OUT[S_1]\\,\\sqcup\\,OUT[S_2]) \\\\ &amp;=f_{S_3}(f_{S_1}(IN[S_1])\\,\\sqcup\\,f_{S_2}(IN[S_2])) \\\\ &amp;=f_{S_3}(f_{S_1}(OUT[Entry])\\,\\sqcup\\,f_{S_2}(OUT[Entry])) \\\\ \\textcolor{red}{MOP[S_4]}&amp;=f_{S_3}(f_{S_1}(OUT[Entry]))\\,\\sqcup\\,f_{S_3}(f_{S_2}(OUT[Entry])) \\\\ \\end{aligned} \\qquad \\Rightarrow \\qquad \\begin{aligned} \\textcolor{blue}{Ours}&amp;=F(x\\sqcup y) \\\\ \\textcolor{red}{MOP}&amp;=F(x)\\sqcup F(y) \\\\ \\end{aligned} \\end{aligned} IN[S4​]MOP[S4​]​=OUT[S3​]=fS3​​(IN[S3​])=fS3​​(OUT[S1​]⊔OUT[S2​])=fS3​​(fS1​​(IN[S1​])⊔fS2​​(IN[S2​]))=fS3​​(fS1​​(OUT[Entry])⊔fS2​​(OUT[Entry]))=fS3​​(fS1​​(OUT[Entry]))⊔fS3​​(fS2​​(OUT[Entry]))​⇒OursMOP​=F(x⊔y)=F(x)⊔F(y)​​ 根据最小上界 sqcupsqcupsqcup 的定义，我们有 x⊑x⊔yx\\sqsubseteq x\\sqcup yx⊑x⊔y 和 y⊑x⊔yy\\sqsubseteq x\\sqcup yy⊑x⊔y； 因为转换函数 F 是单调的，我们有 F(x)⊑F(x⊔y)F(x)\\sqsubseteq F(x\\sqcup y)F(x)⊑F(x⊔y) 和 F(y)⊑F(x⊔y)F(y)\\sqsubseteq F(x\\sqcup y)F(y)⊑F(x⊔y)； 这意味着 F(x⊔y)F(x\\sqcup y)F(x⊔y) 是 F(x)F(x)F(x) 和 F(y)F(y)F(y) 的一个上界； 因为 F(x)⊔F(y)F(x)\\sqcup F(y)F(x)⊔F(y) 是 F(x)F(x)F(x) 和 F(y)F(y)F(y) 的最小上界，我们有 F(x)⊔F(y)⊑F(x⊔y)F(x)\\sqcup F(y)\\sqsubseteq F(x\\sqcup y)F(x)⊔F(y)⊑F(x⊔y)； 因此 MOP⊑Ours\\textcolor{red}{MOP}\\sqsubseteq \\textcolor{blue}{Ours}MOP⊑Ours，即 MOP 是更加精确的。 但是，当 F 是 distributive （F 满足分配率）时，F(x⊔y)=F(x)⊔F(y)F(x\\sqcup y)=F(x)\\sqcup F(y)F(x⊔y)=F(x)⊔F(y)，因此 MOP=Ours\\textcolor{red}{MOP}=\\textcolor{blue}{Ours}MOP=Ours，此时 Iterative Algorithm 和 MOP 一样精确。 BitVector 或 Gen/Kill (set union/intersection for join/meet) 问题都是满足分配率的。 Constant Propagation Given a variable x at program point p, determine whether x is guaranteed to hold a constant value at p. 对于在程序点 p 的一个变量 x，判断 x 的值在 p 点是否为一个常量（恒定值）。 CFG 中每个节点的 OUT 包含一个 (x, v) 集合，x 是变量，v 是变量 x 在该点的值。 上文中提到的数据流分析框架 (D, L, F)： Direaction 显然对于常量传播分析（Constant Propagation Analysis），data flow 是 forward。 Lattice Domian of the values V 常量传播分析是一种 must analysis，其最小上界为 undefined，因为在程序开始之前我们并不知道每个程序点上变量的具体值，因此视为未定义的；最大下界是 NAC（Not A Constant），而中间就是各种常量。 Meet Operator ⊓\\sqcap⊓ NAC⊓v=NACUNDEF⊓v=vc⊓v= ?c⊓c=cc1⊓c2=NAC\\begin{align} &amp;\\mathrm{NAC}\\sqcap v=\\mathrm{NAC} \\\\ &amp;\\mathrm{UNDEF}\\sqcap v=v \\\\ &amp;c\\sqcap v =\\,? \\\\ &amp;c\\sqcap c=c \\\\ &amp;c_1\\sqcap c_2=\\mathrm{NAC} \\\\ \\end{align} ​NAC⊓v=NACUNDEF⊓v=vc⊓v=?c⊓c=cc1​⊓c2​=NAC​​ 公式(2) 表示常量传播分析通常不关注未初始化的变量（Uninitialized variables），即允许漏报。 在每个程序汇聚点（path confluence, PC），我们需要对所有进入的数据流值使用 meet 操作。 Transfer Functions Given a statement s:x=…s: x = \\ldotss:x=…, we define its transfer function F as F: OUT[s]=gen∪(IN[s]−{(x, _)})F:\\,OUT[s]=gen\\cup (IN[s]-\\{(x,\\,\\_)\\}) F:OUT[s]=gen∪(IN[s]−{(x,_)}) (We use val(x) to denote the lattice value that variable x holds) s:x=c; //&nbsp;c&nbsp;is&nbsp;a&nbsp;constantgen={(x, c)}s:x=y;gen={(x, val(y))}s:x=y op z;gen={(x, f(y, z))}f(y,z)={val(y) op val(z)//&nbsp;if&nbsp;val(y)&nbsp;and&nbsp;val(z)&nbsp;are&nbsp;constantsNAC//&nbsp;if&nbsp;val(y)&nbsp;or&nbsp;val(z)&nbsp;is&nbsp;NACUNDEF//&nbsp;otherewize\\begin{array}{l} s: x = c;\\,\\text{\\color{green}{// c is a constant}} &amp;gen=\\{(x,\\,c)\\} \\\\ s: x = y; &amp;gen=\\{(x,\\,val(y))\\} \\\\ s: x = y\\;op\\;z; &amp;gen=\\{(x,\\,f(y,\\,z))\\} \\\\ \\\\ f(y,z)=\\begin{cases} val(y)\\;op\\;val(z) &amp;\\text{\\color{green}{// if $val(y)$ and $val(z)$ are constants}} \\\\ \\mathrm{NAC} &amp;\\text{\\color{green}{// if $val(y)$ or $val(z)$ is NAC}} \\\\ \\mathrm{UNDEF} &amp;\\text{\\color{green}{// otherewize}} \\end{cases} \\end{array} s:x=c;//&nbsp;c&nbsp;is&nbsp;a&nbsp;constants:x=y;s:x=yopz;f(y,z)=⎩⎨⎧​val(y)opval(z)NACUNDEF​//&nbsp;if&nbsp;val(y)&nbsp;and&nbsp;val(z)&nbsp;are&nbsp;constants//&nbsp;if&nbsp;val(y)&nbsp;or&nbsp;val(z)&nbsp;is&nbsp;NAC//&nbsp;otherewize​​gen={(x,c)}gen={(x,val(y))}gen={(x,f(y,z))} (if s is not an assignment statement, F is the identity function) 常量传播分析是不可分配的（Nondistributivity） F(X⊓Y)={(a,NAC), (b,NAC), (c,NAC)}F(X)⊓F(Y)={(a,NAC), (b,NAC), (c,10)}F(X⊓Y)≠F(X)⊓F(Y)F(X⊓Y)⊑F(X)⊓F(Y)F(X\\sqcap Y)=\\{(a,\\mathrm{NAC}),\\,(b,\\mathrm{NAC}),\\,(c,\\mathrm{NAC})\\} \\\\ F(X)\\sqcap F(Y)=\\{(a,\\mathrm{NAC}),\\,(b,\\mathrm{NAC}),\\,(c,10)\\} \\\\ F(X\\sqcap Y)\\neq F(X)\\sqcap F(Y) \\\\ F(X\\sqcap Y)\\sqsubseteq F(X)\\sqcap F(Y) F(X⊓Y)={(a,NAC),(b,NAC),(c,NAC)}F(X)⊓F(Y)={(a,NAC),(b,NAC),(c,10)}F(X⊓Y)=F(X)⊓F(Y)F(X⊓Y)⊑F(X)⊓F(Y) 常量传播分析具有单调性。 Worklist Algorithm Worklist Algorithm 是 Iterative Algorithm 的优化，Iterative Algorithm 存在冗余计算，Worklist Algorithm 只计算变化的 node。","categories":[{"name":"Program Analysis","slug":"Program-Analysis","permalink":"https://car0ta.github.io/categories/Program-Analysis/"}],"tags":[{"name":"Static Program Analysis","slug":"Static-Program-Analysis","permalink":"https://car0ta.github.io/tags/Static-Program-Analysis/"}]},{"title":"Static Program Analysis (Data Flow Analysis-Applications)","slug":"Static-Program-Analysis-Data-Flow-Analysis-Applications","date":"2022-04-25T12:13:47.000Z","updated":"2022-05-18T14:51:09.561Z","comments":true,"path":"2022/04/25/Static-Program-Analysis-Data-Flow-Analysis-Applications/","link":"","permalink":"https://car0ta.github.io/2022/04/25/Static-Program-Analysis-Data-Flow-Analysis-Applications/","excerpt":"","text":"数据流分析简介 两类分析： may analysis (over-approximation) 程序分析的结果可能是正确的（大部分静态分析都是 may analysis） must analysis (under-approximation) 程序分析的结果一定是正确的 may analysis 和 must analysis 在特定的场景下都是为了 safety analysis (safe-approximation) 预备知识 输入输出状态 每一条 IR 的都会将一个输入状态（Input State）转换为输出状态（Output State） 输入状态/输出状态和语句前/后的程序点（program point）相关联 在数据流分析中，我们将每一个程序点和一个数据流值进行关联，这个数据流值代表当前程序点所有可能的程序状态的抽象表示。 数据流分析是在一系列 safe-approximation 规则约束下，解出每一条 statement/BB 的 IN 和 OUT。 IN 和 OUT 指每一条语句的输入和输出 约束（constraint）基于语义（transfer functions）和控制流 转换函数的约束 前向分析和后向分析 控制流的约束 定义可达性分析 (Reaching Definition Analysis) 本节不涉及的两个概念： Method Calls 函数调用涉及到过程间分析（Inter-procedural Analysis），本节只针对过程内分析（Intra-procedural Analysis） Aliases 两个变量实际指向同一块内存地址，将在指针分析（Pointer Analysis）中介绍 定义可达性 (Reaching Definitions) A definition d at program point p reaches a point q if there is a path from p to q such that d is not “killed” along that path. 变量 v 的定义（definition）是一条赋值语句 在程序点 p 处的变量 v 的定义能够到达程序点 q 当且仅当存在一条从 p 到 q 的路径且路径上没有出现变量 v 的新定义 Reaching Definitions 可以用来检测可能的未定义变量，例如变量 v 在使用之前未定义（undefined reached v） 定义可达性分析算法 Data Flow Values/Facts 程序中所有变量的定义 可以用 bit vectors 表示，有多少个赋值语句就有多少位；0表示定义不可达，1表示定义可达。 定义 Transfer Function D:v=xopyD: v = x op yD:v=xopy，这条语句生成（generate）了变量 v 的一个定义 D，并删除（kill）了程序中该条语句之前的所有关于变量 v 的定义，即剩余还没到达的定义不受影响。 OUT[B]=genB∪(IN[B]−killB)OUT[B]={gen}_{B}\\cup(IN[B]-{kill}_{B}) OUT[B]=genB​∪(IN[B]−killB​) 定义 Control-Flow Handling IN[B] 是所有 B 的所有前驱结点的 OUT 的并集 IN[B]=⋃P a predecessor of BOUT[P]IN[B]={\\bigcup }_{P\\, a\\, predecessor\\, of\\, B}OUT[P] IN[B]=⋃PapredecessorofB​OUT[P] 算法设计（经典的迭代算法） 将 Entry 和 BB (basic block) 的 OUT 都设置为空 分析结果 算法最终为什么会结束（到达不动点，Pixed point） gen 和 kill 是不会变的 当一些变化流入 IN[S] 时，这些变化要么被 kill 掉，要么 survivor 加入到 OUT[S] 中 新加入 OUT[S] 中变化要么来自于 gen，要么来自于 survivor，这些将不再改变 因此 OUT[S] 是不会缩小的（e.g., 0-&gt;1 or 1-&gt;1） 因为这些变化是有限的（最多程序中的所有定义的变量都能到达），因此当 OUT[S] 不再发生变化时迭代完成，算法终止。 活跃变量分析 (Live Variables Analysis) 活跃变量 (Live Variables) Live variables analysis tells whether the value of variable v at program point p could be used along some path in CFG starting at p. If so, v is live at p; otherwise, v is dead at p. 活跃变量分析用来确定程序点 p 处的变量 v 的值是否在从 p 出发的某条路径上使用，如果使用到了 v，则称 v 在 p 点活跃的。 变量 v 在 p 点活跃当且仅当存在一条从 p 开始的路径上使用了变量 v，且在使用前没有被重新定义。 活跃变量分析算法 Data Flow Values/Facts 程序中的所有变量可以表示为一个位向量（bit vectors），0表示变量 dead，1表示变量 live。 定义 Transfer Function 和 Control-Flow Handling 后向分析（backward analysis） 如果在一个基本块中，变量 v 先 redefine 后 use，那么最初 define 的变量 v 相当于没有被 use。 IN[B]=useB∪(OUT[B]−defB)OUT[B]=⋃S a successor of BIN[S]IN[B]={use}_{B}\\cup(OUT[B]-{def}_{B}) \\\\ OUT[B]={\\bigcup}_{S\\, a\\, successor\\, of\\, B}IN[S] IN[B]=useB​∪(OUT[B]−defB​)OUT[B]=⋃SasuccessorofB​IN[S] 算法设计 分析结果 可用表达式分析 (Available Expressions Analysis) 可用表达式 (Available Expressions) An expression x op y is available at program point p if (1) all paths from the entry to p must pass througth the evaluation of x op y, and (2) after the last evaluation of x op y, there is no redefinition of x or y. 可用表达式可以用于全局公共子表达式的计算。也就是说，如果一个表达式在上次计算的值在这次仍然可用，我们就可以直接用上次计算的结果而不需要重新计算。 可用表达式分析算法 Data Flow Values/Facts 程序中的所有表达式可以用一个位向量表示。 定义 Transfer Function 和 Control Flow Handling OUT[B]=genB∪(IN[B]−killB)IN[B]=⋂P a predecessor of BOUT[P]OUT[B]={gen}_{B}\\cup (IN[B]-{kill}_{B}) \\\\ IN[B]={\\bigcap}_{P\\, a\\, predecessor\\, of\\, B}OUT[P] OUT[B]=genB​∪(IN[B]−killB​)IN[B]=⋂PapredecessorofB​OUT[P] 算法设计 分析结果 总结 Reaching Definitions Live Variables Available Expressions Domain Set of Definitions Set of Variables Set of Expressions Direction Forward Backward Forward May/Must May May Must Boundary OUT[entry]=∅OUT[entry]=\\emptysetOUT[entry]=∅ IN[exit]=∅IN[exit]=\\emptysetIN[exit]=∅ OUT[entry]=∅OUT[entry]=\\emptysetOUT[entry]=∅ Initialization OUT[B]=∅OUT[B]=\\emptysetOUT[B]=∅ IN[B]=∅IN[B]=\\emptysetIN[B]=∅ OUT[B]=∪OUT[B]=\\cupOUT[B]=∪ Transfer function OUT[B]=genB∪(IN[B]−killB)OUT[B]={gen}_{B}\\cup(IN[B]-{kill}_{B})OUT[B]=genB​∪(IN[B]−killB​) IN[B]=useB∪(OUT[B]−defB)IN[B]={use}_{B}\\cup(OUT[B]-{def}_{B})IN[B]=useB​∪(OUT[B]−defB​) OUT[B]=genB∪(IN[B]−killB)OUT[B]={gen}_{B}\\cup (IN[B]-{kill}_{B})OUT[B]=genB​∪(IN[B]−killB​) Meet ∪\\cup∪ ∪\\cup∪ ∩\\cap∩","categories":[{"name":"Program Analysis","slug":"Program-Analysis","permalink":"https://car0ta.github.io/categories/Program-Analysis/"}],"tags":[{"name":"Static Program Analysis","slug":"Static-Program-Analysis","permalink":"https://car0ta.github.io/tags/Static-Program-Analysis/"}]},{"title":"Static Program Analysis (Intermediate Representation)","slug":"Static-Program-Analysis-Intermediate-Representation","date":"2022-04-22T06:31:20.000Z","updated":"2023-03-07T13:32:23.120Z","comments":true,"path":"2022/04/22/Static-Program-Analysis-Intermediate-Representation/","link":"","permalink":"https://car0ta.github.io/2022/04/22/Static-Program-Analysis-Intermediate-Representation/","excerpt":"","text":"编译器和静态分析器 编译器（Compiler）将源代码（Source code）转换为机器代码（Machine code），步骤如下： 词法分析器（Scanner）：结合正则表达式（Regular Expression），通过词法分析（Lexical Analysis）将源代码转换成 Tokens 语法分析器（Parser）：结合上下文无关文法（Context-Free Grammar），通过语法分析（Syntax Analysis）将 Tokens 解析为抽象语法树（Abstract Syntax Tree, AST） 语义分析器（Type checker）：结合属性文法（Attribute Grammar），通过语义分析（Semantic Analysis）将 AST 解析为 Decorated AST 翻译器（Translator）：将 Decorated AST 翻译成三地址码这样的中间表示（IR） 代码生成器（Code Generator）：将 IR 转换成机器码 静态分析器则是基于 IR 做静态分析（如代码优化）。 AST vs. IR AST high-level 且贴近语法结构 通常是依赖于语言的 适合快速的类型检查进行语义分析 缺少控制流信息 IR low-level 且贴近机器码 通常是独立于语言的（语言无关性） IR 形式简洁且统一 包含控制流信息 因此，IR 通常作为静态分析的基础。 三地址码 三地址码（Three-Address Code, 3AC）是一种常用的 IR，三地址码中每一条指令的右侧最多只能有一个操作符，因此通常需要引入中间变量。 t = a + b + 3==&gt;t1 = a + bt2 = t1 + 3 每一个三地址码最多只有3个地址，地址可以是： 变量名（Name）：a, b 常量值（Constant）：3 编译器生成的临时变量（Compiler-generated temporary）：t1, t2 常见的三地址码的形式： Soot Soot 是 Java 中最流行的静态分析框架，Soot 中的一种常用 IR 是 jimple，它是一种类型化的、三地址的、基于语句的中间表示（typed, 3-addresses, statement based IR），用于简化 Java 字节码以便于分析。 jimple 中共有4中函数调用： specialinvoke: call constructor, call superclass methods, call private methods virtualinvoke: instance method calls (virtual dispatch) interfaceinvoke: cannot optimization, checking interface implementation staticinvoke: call static methods Java7 引入了 dynamicinvoke method signature（方法签名）：class name: return type method name(parameter1 type, parameter2 type, …) init vs. clinit init 是类的默认构造函数 clinit 是类的静态初始化函数 SSA* 在 SSA（Static Single Assignment，静态单赋值） 中每一个变量赋值都会用不同的名称。 每个变量定义用一个新的名称 后续使用中选择最新的变量 每一个变量只有一个定义 3AC | SSAp = a + b p1 = a + bq = p - c q1 = p1 - cp = q * d p2 = q1 * dq = p + q q2 = p2 + q1 当变量在程序控制流的汇聚点使用时，会存在多个变量的问题。 这时会引入一个特殊的合并操作符 φ，φ(x0, x1) 会根据控制流的真实路径确定选择哪一个变量。 SSA 的优势： 控制流信息间接地集成到了唯一的变量名中 SSA 能够帮助到一些简化分析，如控制流不敏感分析（速度快但精度差） 变量的定义和使用是显式的 在一些请求式的任务中，数据的存储和传输会更加高效 有些优化基于 SSA 效果更好（如条件常量传播，全局变量编号等问题） SSA 的缺点： SSA 会引入太多的变量和 φ function 在转换为机器码时会引入低效率的问题（如大量的复制操作） Basic Blocks (BB) 基本块是满足以下性质的最大的连续三地址码指令集合： 只存在一个入口，即块中的第一条指令 只存在一个出口，即块中的最后一条指令 如何构建基本块： 输入：程序 P 的三地址码序列 输出：程序 P 的基本块 方法： 确定程序 P 中的 leaders 程序 P 的第一条指令是一个 leader 任何跳转的目标指令是一个 leader 任何跳转指令的下一跳指令是一个 leader 构建程序 P 的基本块 一个基本块包含一个 leader 及其后续的指令，直到下一个 leader 🌰 Control Flow Graph (CFG) CFG 中的节点是基本块，CFG 的构建流程： 从基本块 A 到基本块 B 添加一条边 A 的结尾有一条指向 B 的跳转指令 A 的结尾紧接着 B 的开头且A的结尾不是一条无条件跳转的指令 将跳转指令的标号转换为基本块的标号 若 A -&gt; B，则称 A 是 B 的前驱（predecessor），B 是 A 的后继（successor） 构建好基本块后，需要额外添加两个节点 —— 入口（Entry）和出口（Exit） 这两个指令不对应任何 IR 入口有一条边指向包含第一条 IR 指令的基本块 如果一个基本块中包含 IR 中的最后一条指令，那么存在从这个基本块到出口的一条边","categories":[{"name":"Program Analysis","slug":"Program-Analysis","permalink":"https://car0ta.github.io/categories/Program-Analysis/"}],"tags":[{"name":"Static Program Analysis","slug":"Static-Program-Analysis","permalink":"https://car0ta.github.io/tags/Static-Program-Analysis/"}]},{"title":"Static Program Analysis (Introduction)","slug":"Static-Program-Analysis-Introduction","date":"2022-04-22T03:22:07.000Z","updated":"2022-05-10T16:16:17.798Z","comments":true,"path":"2022/04/22/Static-Program-Analysis-Introduction/","link":"","permalink":"https://car0ta.github.io/2022/04/22/Static-Program-Analysis-Introduction/","excerpt":"","text":"学习资料： 南大软件分析课程视频 https://space.bilibili.com/2919428/video 南大软件分析课件 https://pascal-group.bitbucket.io/courses/program-analysis-2020f/ 静态程序分析公开教程 https://spa-book.pblo.gq/ 静态程序分析课程笔记 https://anemone.top/categories/Program-Language/ 程序语言的知识体系 过去十年语言的核心（language core）变化很少，但是程序变得越来越复杂。 编程语言类型： 命令式编程语言：Java, C, C++，程序按照指令一条一条地执行 函数式编程语言：Haskell，把逻辑包装成函数执行 逻辑式编程语言（声明式语言）：Prolog，通过逻辑与或非进行计算得到最终结果 静态分析的作用 程序可靠性（Program Reliability） 空指针引用，内存泄漏等 程度安全性（Program Security） 隐私信息泄露，注入攻击等 编译优化（Compile Optimization） Dead code elimination（程序无法执行到的一些代码）, code motion（如循环中重复初始化的变量可以移动到循环外） 程序理解（Program Understanding） IDE 调用关系，变量类型指示 什么是静态分析 静态分析是指在程序运行前通过对程序进行分析以得到程序的行为并推断出该程序是否具有某些属性。 程序 P 是否存在隐私信息泄露？ 程序 P 是否有空指针？ 所有的 cast（类型转换）操作都是安全的吗？ v1 和 v2 所指向的是同一块内存地址吗？（加锁） assert 语句是否会 fail？ 程序 P 中是否存在死代码？如何优化？ 莱斯定理（Rice’s Theorem） Any non-trial property of the behavior of program in a r.e. language is undecidable. r.e. language（recursive enumerable language，递归可枚举语言） = Turing-recognizable language（图灵可识别语言）。一个语言是递归可枚举的语言，当且仅当存在一个图灵机，该图灵机仅接收该语言中的字符串（也就是说对于不在该语言中的字符串，该图灵机可以拒绝或者永不停机）。现有的大部分语言如 Java、C 等都是递归可枚举语言。 非平凡性质（non-trial）：一种属性满足部分递归可枚举语言，而在另一部分中不满足。对应的，平凡性质是指一种属性对所有的递归可枚举语言都满足或者都不满足。简单理解为上节中静态分析关注的一些问题都是非平凡性质。 不可判定的（undecidable）：不可判定是指某个问题无法得到准确的 Yes or No 的答案。 莱斯定理指出，递归可枚举语言的所有非平凡性质都是不可判定的。 在静态分析领域中，莱斯定理可理解为不存在一个完美的（Perfect）静态分析（既 sound 又 complete 的静态分析）能够准确判断一个程序 P 是否存在一些 non-trial 的属性（如是否存在内存泄漏）。但是可以存在一个 Useful 的静态分析。 https://blog.linyinfeng.com/posts/rices-theorem/ Sound &amp; Complete 🌰 假设程序 P 存在真实的 10 个内存泄漏，Complete 检测到其中的 6 个，而 Sound 检测到 16个（包含真实的 10个）。 Complete Under-approximate（欠拟合） false negative（存在漏报） Sound Over-approximate（过拟合） false positive（存在误报） Useful static analysis Compromise soundness -&gt; completeness（false negatives，存在漏报） Compromise completeness -&gt; soundness（false positives，存在误报） 程序分析中绝大部分选择 soundness 的分析（Sound but not fully-precise static analysis），即接受误报；Soundness 对于编译优化、程序验证等一类问题是非常重要的。 🌰 Safe Cast 静态分析是在确保 soundness 的前提下，在精度（precision）和速度（speed）之间做一个平衡。 🌰 if-else 静态分析的技术要点： Abstraction Over-approximation Transfer functions Control flows 静态分析示例 分析程序 P 中所有变量的符号（﹢, ﹣, 0） Abstraction Unknown：未知，既可能整也可能负也可能为 0 undefined：错误 Over-approximation: Transfer Functions 在静态分析中，Transfer functions 定义了每条程序语句在抽象值上进行计算的规则。 Transfer functions 根据程序分析的目标和程序中每条语句的语义进行构建。 Over-approximation: Control Flows 在实践中我们不可能枚举出所有的路径，因此程序分支的汇聚点需要进行 merge。","categories":[{"name":"Program Analysis","slug":"Program-Analysis","permalink":"https://car0ta.github.io/categories/Program-Analysis/"}],"tags":[{"name":"Static Program Analysis","slug":"Static-Program-Analysis","permalink":"https://car0ta.github.io/tags/Static-Program-Analysis/"}]},{"title":"Study Record","slug":"Study-Record","date":"2022-04-13T11:37:53.000Z","updated":"2022-09-08T11:18:04.354Z","comments":true,"path":"2022/04/13/Study-Record/","link":"","permalink":"https://car0ta.github.io/2022/04/13/Study-Record/","excerpt":"","text":"2022 4.11 Android 13 Developer OverView 一览 https://mp.weixin.qq.com/s/CvGwijJtXaK_o1WQ_mc_tQ APTMalInsight：基于系统调用信息和本体知识框架识别和认知APT恶意软件 https://mp.weixin.qq.com/s/GEwV3EiobUjI2XdX1q8Cuw Large-scale Security Measurements on the Android Firmware Ecosystem https://mp.weixin.qq.com/s/ykvCJ8biYHunpxjIGW8-uA 4.18 Android 前台服务 https://codyi96.github.io/2020/08/02/android-service/ Android 应用无响应机制 (ANR) http://gityuan.com/2019/04/06/android-anr/ http://gityuan.com/2016/07/02/android-anr/ startService 启动过程分析 http://gityuan.com/2016/03/06/start-service/ 安全研究员的自我修养 https://evilpan.com/2020/12/27/my2020/ Static Program Analysis (Introduction) https://www.bilibili.com/video/BV1b7411K7P4 Static Program Analysis (Intermediate Representation) https://www.bilibili.com/video/BV1zE411s77Z 4.25 Web3革命：逃离、信仰、大迁徙 https://mp.weixin.qq.com/s/_fZxTDOr2n1IQySjVODB8A PHYjacking: Physical Input Hijacking for Zero-Permission Authorization Attacks on Android https://mp.weixin.qq.com/s/hPIfR-NmU-XT8ANNbClBIw Static Program Analysis (Data Flow Analysis-Applications) 5.9 FRED: Identifying File Re-Delegation in Android System Services https://mp.weixin.qq.com/s/h3UQb5eRKKizffM57KzSXg Probe the Proto: Measuring Client-Side Prototype Pollution Vulnerabilities of One Million Real-world Websites https://mp.weixin.qq.com/s/CBgqwgwcB2vOB55lgFvPVQ 代码安全审计之道 https://evilpan.com/2022/01/22/code-audit/ 阿里味儿的代码审计随想 https://evilpan.com/2022/05/01/code-audit-thoughts/ Static Program Analysis (Data Flow Analysis-Foundations) Static Program Analysis (Interprocedural Analysis) 5.16 Exploiting memory corruption vulnerabilities on Android https://blog.oversecured.com/Exploiting-memory-corruption-vulnerabilities-on-Android/ Static Program Analysis (Pointer Analysis) Static Program Analysis (Pointer Analysis-Foundations) 5.23 Android 嵌套 Intent 的隐患以及解决方案 https://mp.weixin.qq.com/s/5OdN8jTUGFGVy0exPS6DpQ Cross-Language Attacks https://mp.weixin.qq.com/s/x-KjRaJAdtHT4RZPzN6OGw Detection of Repackaged Android Malware with Code-Heterogeneity Features https://ieeexplore.ieee.org/document/8018581 Static Program Analysis (Pointer Analysis-Context Sensitivity) 5.30 Ghost in the Binder: Binder Transaction Redirection Attacks in Android System Services (CCS’21) PolyScope: Multi-Policy Access Control Analysis to Compute Authorized Attack Operations in Android Systems (Usenix Security’22) Preventing and Detecting State Inference Attacks on Android (NDSS’21) Exploit the Last Straw That Breaks Android Systems (S&amp;P’22) All your app links are belong to us: understanding the threats of instant apps based attacks (FSE’20) 6.6 Android 13 针对 Intent Filter 安全的再升级 https://mp.weixin.qq.com/s/zLBnpToeLrVqVG0iRyjaWA Android 12 AppSearch https://developer.android.com/guide/topics/search/appsearch 7.11 沉浸式体验杀猪盘-社、黄、赌汇聚融合 https://mp.weixin.qq.com/s/A9P5sFsCjEOuKBSAFCb2jA Mistrust Plugins You Must: A Large-Scale Study Of Malicious Plugins In WordPress Marketplaces https://mp.weixin.qq.com/s/GEC82MFProZt36Hswr0k4w Android 静态分析框架从01到10 https://mp.weixin.qq.com/s/NUu8aOYr5mXSpOIUZeJYfA https://mp.weixin.qq.com/s/oKm5FgPmmf4-3iediqFsfg https://mp.weixin.qq.com/s/-0clY-O7uODpzAzacQCuVA 8.22 Android 中特殊的攻击面 https://paper.seebug.org/1174/ https://paper.seebug.org/1175/ https://paper.seebug.org/1269/ 9.4 Android 应用沙盒机制 https://wrlus.com/android-security/android-app-protect/ TODO","categories":[],"tags":[]},{"title":"Vul Pattern 1","slug":"Vul-Pattern-1","date":"2022-04-13T07:37:13.000Z","updated":"2022-06-12T14:29:59.951Z","comments":true,"path":"2022/04/13/Vul-Pattern-1/","link":"","permalink":"https://car0ta.github.io/2022/04/13/Vul-Pattern-1/","excerpt":"","text":"CVE-2020-0001 漏洞原理 在 frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java 的 getProcessRecordLocked 方法中，系统会在进程启动前判断同一用户是否已经启动相同包名的进程，如果启动进程的 uid 为 SYSTEM_UID（1000），则不会首先通过 mProcessNames.get(processName, uid) 方法同时根据包名和 uid 寻找进程，而是先调用 mProcessNames.getMap().get(processName) 方法通过进程名寻找相应的进程，再通过 if (UserHandle.isApp(procUid) || !UserHandle.isSameUser(procUid, uid)) 判断找到的进程是否是属于当前用户。 final ProcessRecord getProcessRecordLocked(String processName, int uid, boolean keepIfLarge) { if (uid == SYSTEM_UID) { // The system gets to run in any process. If there are multiple // processes with the same uid, just pick the first (this // should never happen). SparseArray&lt;ProcessRecord&gt; procs = mProcessNames.getMap().get(processName); if (procs == null) return null; final int procCount = procs.size(); for (int i = 0; i &lt; procCount; i++) { final int procUid = procs.keyAt(i); if (UserHandle.isApp(procUid) || !UserHandle.isSameUser(procUid, uid)) { // Don't use an app process or different user process for system component. continue; } return procs.valueAt(i); } } ProcessRecord proc = mProcessNames.get(processName, uid); UserHandle.isApp(procUid) 会判断当前找到的进程所属用户是否为 regular app 级别（10000-19999）。如果在用户 App 中启动一个系统应用包名的服务（如 Settings），isApp 会返回 true，则会执行 continue 跳过当前进程，即认为该进程不是 SYSTEM_UID 启动。但是参考注释，如果用户 App 中启动一个具有系统应用包名的隔离服务，则 uid &gt; 90000，isApp 返回 false，即认为该进程是 SYSTEM_UID 启动。 /** * Whether a UID belongs to a regular app. *Note* \"Not a regular app\" does not mean * \"it's system\", because of isolated UIDs. Use {@link #isCore} for that. * @hide */public static boolean isApp(int uid) { if (uid &gt; 0) { final int appId = getAppId(uid); return appId &gt;= Process.FIRST_APPLICATION_UID &amp;&amp; appId &lt;= Process.LAST_APPLICATION_UID; } else { return false; }} 漏洞模式 寻找进程有两种方式，一种直接通过 mProcessNames.get(processName, uid) 方法同时根据包名和 uid 查找进程；另一种是先通过 mProcessNames.getMap().get(processName) 方法根据包名找到进程组，再判断是否属于当前用户。这种一步分两步的操作可以重点关注两步操作的过程中是否存在绕过。 当看到判断某类 id 是否在一定范围内时，可以思考是否存在特殊情况使该类 id 不在此范围内。 参考 https://www.60ru.com/3842.html https://github.com/Zachinio/CVE-2020-0001 https://android.googlesource.com/platform/frameworks/base/+/f5911687e9b9b9a9c26e1cb58f31c941fb199195","categories":[{"name":"Android Vuls","slug":"Android-Vuls","permalink":"https://car0ta.github.io/categories/Android-Vuls/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://car0ta.github.io/tags/Android/"},{"name":"Vuls","slug":"Vuls","permalink":"https://car0ta.github.io/tags/Vuls/"}]}],"categories":[{"name":"Program Analysis","slug":"Program-Analysis","permalink":"https://car0ta.github.io/categories/Program-Analysis/"},{"name":"Android Vuls","slug":"Android-Vuls","permalink":"https://car0ta.github.io/categories/Android-Vuls/"},{"name":"Android OS","slug":"Android-OS","permalink":"https://car0ta.github.io/categories/Android-OS/"}],"tags":[{"name":"Static Program Analysis","slug":"Static-Program-Analysis","permalink":"https://car0ta.github.io/tags/Static-Program-Analysis/"},{"name":"Android","slug":"Android","permalink":"https://car0ta.github.io/tags/Android/"},{"name":"Vuls","slug":"Vuls","permalink":"https://car0ta.github.io/tags/Vuls/"}]}